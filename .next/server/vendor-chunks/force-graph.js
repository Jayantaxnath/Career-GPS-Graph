"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/force-graph";
exports.ids = ["vendor-chunks/force-graph"];
exports.modules = {

/***/ "(ssr)/./node_modules/force-graph/dist/force-graph.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/force-graph/dist/force-graph.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ forceGraph)\n/* harmony export */ });\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/./node_modules/d3-zoom/src/index.js\");\n/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! d3-drag */ \"(ssr)/./node_modules/d3-drag/src/drag.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/min.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/max.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/sum.js\");\n/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! lodash-es */ \"(ssr)/./node_modules/lodash-es/throttle.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tweenjs/tween.js */ \"(ssr)/./node_modules/@tweenjs/tween.js/dist/tween.esm.js\");\n/* harmony import */ var kapsule__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! kapsule */ \"(ssr)/./node_modules/kapsule/dist/kapsule.mjs\");\n/* harmony import */ var accessor_fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! accessor-fn */ \"(ssr)/./node_modules/accessor-fn/dist/accessor-fn.mjs\");\n/* harmony import */ var canvas_color_tracker__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! canvas-color-tracker */ \"(ssr)/./node_modules/canvas-color-tracker/dist/canvas-color-tracker.mjs\");\n/* harmony import */ var float_tooltip__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! float-tooltip */ \"(ssr)/./node_modules/float-tooltip/dist/float-tooltip.mjs\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/simulation.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/link.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/manyBody.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/center.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/radial.js\");\n/* harmony import */ var bezier_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! bezier-js */ \"(ssr)/./node_modules/bezier-js/src/bezier.js\");\n/* harmony import */ var index_array_by__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! index-array-by */ \"(ssr)/./node_modules/index-array-by/dist/index-array-by.mjs\");\n/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale */ \"(ssr)/./node_modules/d3-scale/src/ordinal.js\");\n/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale-chromatic */ \"(ssr)/./node_modules/d3-scale-chromatic/src/categorical/Paired.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n  if (typeof document === 'undefined') {\n    return;\n  }\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z = \".force-graph-container canvas {\\n  display: block;\\n  user-select: none;\\n  outline: none;\\n  -webkit-tap-highlight-color: transparent;\\n}\\n\\n.force-graph-container .clickable {\\n  cursor: pointer;\\n}\\n\\n.force-graph-container .grabbable {\\n  cursor: move;\\n  cursor: grab;\\n  cursor: -moz-grab;\\n  cursor: -webkit-grab;\\n}\\n\\n.force-graph-container .grabbable:active {\\n  cursor: grabbing;\\n  cursor: -moz-grabbing;\\n  cursor: -webkit-grabbing;\\n}\\n\";\nstyleInject(css_248z);\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _construct(t, e, r) {\n  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);\n  var o = [null];\n  o.push.apply(o, e);\n  var p = new (t.bind.apply(t, o))();\n  return p;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: true,\n    configurable: true,\n    writable: true\n  }) : e[r] = t, e;\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = true,\n      o = false;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = true, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), true).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r);\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\n\nvar autoColorScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n\n// Autoset attribute colorField by colorByAccessor property\n// If an object has already a color, don't set it\n// Objects can be nodes or links\nfunction autoColorObjects(objects, colorByAccessor, colorField) {\n  if (!colorByAccessor || typeof colorField !== 'string') return;\n  objects.filter(function (obj) {\n    return !obj[colorField];\n  }).forEach(function (obj) {\n    obj[colorField] = autoColorScale(colorByAccessor(obj));\n  });\n}\n\nfunction getDagDepths (_ref, idAccessor) {\n  var nodes = _ref.nodes,\n    links = _ref.links;\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref2$nodeFilter = _ref2.nodeFilter,\n    nodeFilter = _ref2$nodeFilter === void 0 ? function () {\n      return true;\n    } : _ref2$nodeFilter,\n    _ref2$onLoopError = _ref2.onLoopError,\n    onLoopError = _ref2$onLoopError === void 0 ? function (loopIds) {\n      throw \"Invalid DAG structure! Found cycle in node path: \".concat(loopIds.join(' -> '), \".\");\n    } : _ref2$onLoopError;\n  // linked graph\n  var graph = {};\n  nodes.forEach(function (node) {\n    return graph[idAccessor(node)] = {\n      data: node,\n      out: [],\n      depth: -1,\n      skip: !nodeFilter(node)\n    };\n  });\n  links.forEach(function (_ref3) {\n    var source = _ref3.source,\n      target = _ref3.target;\n    var sourceId = getNodeId(source);\n    var targetId = getNodeId(target);\n    if (!graph.hasOwnProperty(sourceId)) throw \"Missing source node with id: \".concat(sourceId);\n    if (!graph.hasOwnProperty(targetId)) throw \"Missing target node with id: \".concat(targetId);\n    var sourceNode = graph[sourceId];\n    var targetNode = graph[targetId];\n    sourceNode.out.push(targetNode);\n    function getNodeId(node) {\n      return _typeof(node) === 'object' ? idAccessor(node) : node;\n    }\n  });\n  var foundLoops = [];\n  traverse(Object.values(graph));\n  var nodeDepths = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(graph).filter(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n      node = _ref5[1];\n    return !node.skip;\n  }).map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n      id = _ref7[0],\n      node = _ref7[1];\n    return _defineProperty({}, id, node.depth);\n  }))));\n  return nodeDepths;\n  function traverse(nodes) {\n    var nodeStack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var currentDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var _loop = function _loop() {\n      var node = nodes[i];\n      if (nodeStack.indexOf(node) !== -1) {\n        var loop = [].concat(_toConsumableArray(nodeStack.slice(nodeStack.indexOf(node))), [node]).map(function (d) {\n          return idAccessor(d.data);\n        });\n        if (!foundLoops.some(function (foundLoop) {\n          return foundLoop.length === loop.length && foundLoop.every(function (id, idx) {\n            return id === loop[idx];\n          });\n        })) {\n          foundLoops.push(loop);\n          onLoopError(loop);\n        }\n        return 1; // continue\n      }\n      if (currentDepth > node.depth) {\n        // Don't unnecessarily revisit chunks of the graph\n        node.depth = currentDepth;\n        traverse(node.out, [].concat(_toConsumableArray(nodeStack), [node]), currentDepth + (node.skip ? 0 : 1));\n      }\n    };\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      if (_loop()) continue;\n    }\n  }\n}\n\n//\n\nvar DAG_LEVEL_NODE_RATIO = 2;\n\n// whenever styling props are changed that require a canvas redraw\nvar notifyRedraw = function notifyRedraw(_, state) {\n  return state.onNeedsRedraw && state.onNeedsRedraw();\n};\nvar updDataPhotons = function updDataPhotons(_, state) {\n  if (!state.isShadow) {\n    // Add photon particles\n    var linkParticlesAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticles);\n    state.graphData.links.forEach(function (link) {\n      var numPhotons = Math.round(Math.abs(linkParticlesAccessor(link)));\n      if (numPhotons) {\n        link.__photons = _toConsumableArray(Array(numPhotons)).map(function () {\n          return {};\n        });\n      } else {\n        delete link.__photons;\n      }\n    });\n  }\n};\nvar CanvasForceGraph = (0,kapsule__WEBPACK_IMPORTED_MODULE_7__[\"default\"])({\n  props: {\n    graphData: {\n      \"default\": {\n        nodes: [],\n        links: []\n      },\n      onChange: function onChange(_, state) {\n        state.engineRunning = false; // Pause simulation\n        updDataPhotons(_, state);\n      }\n    },\n    dagMode: {\n      onChange: function onChange(dagMode, state) {\n        // td, bu, lr, rl, radialin, radialout\n        !dagMode && (state.graphData.nodes || []).forEach(function (n) {\n          return n.fx = n.fy = undefined;\n        }); // unfix nodes when disabling dag mode\n      }\n    },\n    dagLevelDistance: {},\n    dagNodeFilter: {\n      \"default\": function _default(node) {\n        return true;\n      }\n    },\n    onDagError: {\n      triggerUpdate: false\n    },\n    nodeRelSize: {\n      \"default\": 4,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    // area per val unit\n    nodeId: {\n      \"default\": 'id'\n    },\n    nodeVal: {\n      \"default\": 'val',\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeColor: {\n      \"default\": 'color',\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeAutoColorBy: {},\n    nodeCanvasObject: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeCanvasObjectMode: {\n      \"default\": function _default() {\n        return 'replace';\n      },\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeVisibility: {\n      \"default\": true,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkSource: {\n      \"default\": 'source'\n    },\n    linkTarget: {\n      \"default\": 'target'\n    },\n    linkVisibility: {\n      \"default\": true,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkColor: {\n      \"default\": 'color',\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkAutoColorBy: {},\n    linkLineDash: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkWidth: {\n      \"default\": 1,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkCurvature: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkCanvasObject: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkCanvasObjectMode: {\n      \"default\": function _default() {\n        return 'replace';\n      },\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkDirectionalArrowLength: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkDirectionalArrowColor: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkDirectionalArrowRelPos: {\n      \"default\": 0.5,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    // value between 0<>1 indicating the relative pos along the (exposed) line\n    linkDirectionalParticles: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: updDataPhotons\n    },\n    // animate photons travelling in the link direction\n    linkDirectionalParticleSpeed: {\n      \"default\": 0.01,\n      triggerUpdate: false\n    },\n    // in link length ratio per frame\n    linkDirectionalParticleOffset: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    // starting position offset along the link's length, like a pre-delay. Values between [0, 1]\n    linkDirectionalParticleWidth: {\n      \"default\": 4,\n      triggerUpdate: false\n    },\n    linkDirectionalParticleColor: {\n      triggerUpdate: false\n    },\n    linkDirectionalParticleCanvasObject: {\n      triggerUpdate: false\n    },\n    globalScale: {\n      \"default\": 1,\n      triggerUpdate: false\n    },\n    d3AlphaMin: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    d3AlphaDecay: {\n      \"default\": 0.0228,\n      triggerUpdate: false,\n      onChange: function onChange(alphaDecay, state) {\n        state.forceLayout.alphaDecay(alphaDecay);\n      }\n    },\n    d3AlphaTarget: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: function onChange(alphaTarget, state) {\n        state.forceLayout.alphaTarget(alphaTarget);\n      }\n    },\n    d3VelocityDecay: {\n      \"default\": 0.4,\n      triggerUpdate: false,\n      onChange: function onChange(velocityDecay, state) {\n        state.forceLayout.velocityDecay(velocityDecay);\n      }\n    },\n    warmupTicks: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    // how many times to tick the force engine at init before starting to render\n    cooldownTicks: {\n      \"default\": Infinity,\n      triggerUpdate: false\n    },\n    cooldownTime: {\n      \"default\": 15000,\n      triggerUpdate: false\n    },\n    // ms\n    onUpdate: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onFinishUpdate: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onEngineTick: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onEngineStop: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onNeedsRedraw: {\n      triggerUpdate: false\n    },\n    isShadow: {\n      \"default\": false,\n      triggerUpdate: false\n    }\n  },\n  methods: {\n    // Expose d3 forces for external manipulation\n    d3Force: function d3Force(state, forceName, forceFn) {\n      if (forceFn === undefined) {\n        return state.forceLayout.force(forceName); // Force getter\n      }\n      state.forceLayout.force(forceName, forceFn); // Force setter\n      return this;\n    },\n    d3ReheatSimulation: function d3ReheatSimulation(state) {\n      state.forceLayout.alpha(1);\n      this.resetCountdown();\n      return this;\n    },\n    // reset cooldown state\n    resetCountdown: function resetCountdown(state) {\n      state.cntTicks = 0;\n      state.startTickTime = new Date();\n      state.engineRunning = true;\n      return this;\n    },\n    isEngineRunning: function isEngineRunning(state) {\n      return !!state.engineRunning;\n    },\n    tickFrame: function tickFrame(state) {\n      !state.isShadow && layoutTick();\n      paintLinks();\n      !state.isShadow && paintArrows();\n      !state.isShadow && paintPhotons();\n      paintNodes();\n      return this;\n\n      //\n\n      function layoutTick() {\n        if (state.engineRunning) {\n          if (++state.cntTicks > state.cooldownTicks || new Date() - state.startTickTime > state.cooldownTime || state.d3AlphaMin > 0 && state.forceLayout.alpha() < state.d3AlphaMin) {\n            state.engineRunning = false; // Stop ticking graph\n            state.onEngineStop();\n          } else {\n            state.forceLayout.tick(); // Tick it\n            state.onEngineTick();\n          }\n        }\n      }\n      function paintNodes() {\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVisibility);\n        var getVal = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeColor);\n        var getNodeCanvasObjectMode = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeCanvasObjectMode);\n        var ctx = state.ctx;\n\n        // Draw wider nodes by 1px on shadow canvas for more precise hovering (due to boundary anti-aliasing)\n        var padAmount = state.isShadow / state.globalScale;\n        var visibleNodes = state.graphData.nodes.filter(getVisibility);\n        ctx.save();\n        visibleNodes.forEach(function (node) {\n          var nodeCanvasObjectMode = getNodeCanvasObjectMode(node);\n          if (state.nodeCanvasObject && (nodeCanvasObjectMode === 'before' || nodeCanvasObjectMode === 'replace')) {\n            // Custom node before/replace paint\n            state.nodeCanvasObject(node, ctx, state.globalScale);\n            if (nodeCanvasObjectMode === 'replace') {\n              ctx.restore();\n              return;\n            }\n          }\n\n          // Draw wider nodes by 1px on shadow canvas for more precise hovering (due to boundary anti-aliasing)\n          var r = Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize + padAmount;\n          ctx.beginPath();\n          ctx.arc(node.x, node.y, r, 0, 2 * Math.PI, false);\n          ctx.fillStyle = getColor(node) || 'rgba(31, 120, 180, 0.92)';\n          ctx.fill();\n          if (state.nodeCanvasObject && nodeCanvasObjectMode === 'after') {\n            // Custom node after paint\n            state.nodeCanvasObject(node, state.ctx, state.globalScale);\n          }\n        });\n        ctx.restore();\n      }\n      function paintLinks() {\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkVisibility);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkColor);\n        var getWidth = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkWidth);\n        var getLineDash = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkLineDash);\n        var getCurvature = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkCurvature);\n        var getLinkCanvasObjectMode = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkCanvasObjectMode);\n        var ctx = state.ctx;\n\n        // Draw wider lines by 2px on shadow canvas for more precise hovering (due to boundary anti-aliasing)\n        var padAmount = state.isShadow * 2;\n        var visibleLinks = state.graphData.links.filter(getVisibility);\n        visibleLinks.forEach(calcLinkControlPoints); // calculate curvature control points for all visible links\n\n        var beforeCustomLinks = [],\n          afterCustomLinks = [],\n          defaultPaintLinks = visibleLinks;\n        if (state.linkCanvasObject) {\n          var replaceCustomLinks = [],\n            otherCustomLinks = [];\n          visibleLinks.forEach(function (d) {\n            return ({\n              before: beforeCustomLinks,\n              after: afterCustomLinks,\n              replace: replaceCustomLinks\n            }[getLinkCanvasObjectMode(d)] || otherCustomLinks).push(d);\n          });\n          defaultPaintLinks = [].concat(_toConsumableArray(beforeCustomLinks), afterCustomLinks, otherCustomLinks);\n          beforeCustomLinks = beforeCustomLinks.concat(replaceCustomLinks);\n        }\n\n        // Custom link before paints\n        ctx.save();\n        beforeCustomLinks.forEach(function (link) {\n          return state.linkCanvasObject(link, ctx, state.globalScale);\n        });\n        ctx.restore();\n\n        // Bundle strokes per unique color/width/dash for performance optimization\n        var linksPerColor = (0,index_array_by__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(defaultPaintLinks, [getColor, getWidth, getLineDash]);\n        ctx.save();\n        Object.entries(linksPerColor).forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            color = _ref2[0],\n            linksPerWidth = _ref2[1];\n          var lineColor = !color || color === 'undefined' ? 'rgba(0,0,0,0.15)' : color;\n          Object.entries(linksPerWidth).forEach(function (_ref3) {\n            var _ref4 = _slicedToArray(_ref3, 2),\n              width = _ref4[0],\n              linesPerLineDash = _ref4[1];\n            var lineWidth = (width || 1) / state.globalScale + padAmount;\n            Object.entries(linesPerLineDash).forEach(function (_ref5) {\n              var _ref6 = _slicedToArray(_ref5, 2);\n                _ref6[0];\n                var links = _ref6[1];\n              var lineDashSegments = getLineDash(links[0]);\n              ctx.beginPath();\n              links.forEach(function (link) {\n                var start = link.source;\n                var end = link.target;\n                if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n                ctx.moveTo(start.x, start.y);\n                var controlPoints = link.__controlPoints;\n                if (!controlPoints) {\n                  // Straight line\n                  ctx.lineTo(end.x, end.y);\n                } else {\n                  // Use quadratic curves for regular lines and bezier for loops\n                  ctx[controlPoints.length === 2 ? 'quadraticCurveTo' : 'bezierCurveTo'].apply(ctx, _toConsumableArray(controlPoints).concat([end.x, end.y]));\n                }\n              });\n              ctx.strokeStyle = lineColor;\n              ctx.lineWidth = lineWidth;\n              ctx.setLineDash(lineDashSegments || []);\n              ctx.stroke();\n            });\n          });\n        });\n        ctx.restore();\n\n        // Custom link after paints\n        ctx.save();\n        afterCustomLinks.forEach(function (link) {\n          return state.linkCanvasObject(link, ctx, state.globalScale);\n        });\n        ctx.restore();\n\n        //\n\n        function calcLinkControlPoints(link) {\n          var curvature = getCurvature(link);\n          if (!curvature) {\n            // straight line\n            link.__controlPoints = null;\n            return;\n          }\n          var start = link.source;\n          var end = link.target;\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var l = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)); // line length\n\n          if (l > 0) {\n            var a = Math.atan2(end.y - start.y, end.x - start.x); // line angle\n            var d = l * curvature; // control point distance\n\n            var cp = {\n              // control point\n              x: (start.x + end.x) / 2 + d * Math.cos(a - Math.PI / 2),\n              y: (start.y + end.y) / 2 + d * Math.sin(a - Math.PI / 2)\n            };\n            link.__controlPoints = [cp.x, cp.y];\n          } else {\n            // Same point, draw a loop\n            var _d = curvature * 70;\n            link.__controlPoints = [end.x, end.y - _d, end.x + _d, end.y];\n          }\n        }\n      }\n      function paintArrows() {\n        var ARROW_WH_RATIO = 1.6;\n        var ARROW_VLEN_RATIO = 0.2;\n        var getLength = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowLength);\n        var getRelPos = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowRelPos);\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkVisibility);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowColor || state.linkColor);\n        var getNodeVal = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n        var ctx = state.ctx;\n        ctx.save();\n        state.graphData.links.filter(getVisibility).forEach(function (link) {\n          var arrowLength = getLength(link);\n          if (!arrowLength || arrowLength < 0) return;\n          var start = link.source;\n          var end = link.target;\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var startR = Math.sqrt(Math.max(0, getNodeVal(start) || 1)) * state.nodeRelSize;\n          var endR = Math.sqrt(Math.max(0, getNodeVal(end) || 1)) * state.nodeRelSize;\n          var arrowRelPos = Math.min(1, Math.max(0, getRelPos(link)));\n          var arrowColor = getColor(link) || 'rgba(0,0,0,0.28)';\n          var arrowHalfWidth = arrowLength / ARROW_WH_RATIO / 2;\n\n          // Construct bezier for curved lines\n          var bzLine = link.__controlPoints && _construct(bezier_js__WEBPACK_IMPORTED_MODULE_4__.Bezier, [start.x, start.y].concat(_toConsumableArray(link.__controlPoints), [end.x, end.y]));\n          var getCoordsAlongLine = bzLine ? function (t) {\n            return bzLine.get(t);\n          } // get position along bezier line\n          : function (t) {\n            return {\n              // straight line: interpolate linearly\n              x: start.x + (end.x - start.x) * t || 0,\n              y: start.y + (end.y - start.y) * t || 0\n            };\n          };\n          var lineLen = bzLine ? bzLine.length() : Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n          var posAlongLine = startR + arrowLength + (lineLen - startR - endR - arrowLength) * arrowRelPos;\n          var arrowHead = getCoordsAlongLine(posAlongLine / lineLen);\n          var arrowTail = getCoordsAlongLine((posAlongLine - arrowLength) / lineLen);\n          var arrowTailVertex = getCoordsAlongLine((posAlongLine - arrowLength * (1 - ARROW_VLEN_RATIO)) / lineLen);\n          var arrowTailAngle = Math.atan2(arrowHead.y - arrowTail.y, arrowHead.x - arrowTail.x) - Math.PI / 2;\n          ctx.beginPath();\n          ctx.moveTo(arrowHead.x, arrowHead.y);\n          ctx.lineTo(arrowTail.x + arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y + arrowHalfWidth * Math.sin(arrowTailAngle));\n          ctx.lineTo(arrowTailVertex.x, arrowTailVertex.y);\n          ctx.lineTo(arrowTail.x - arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y - arrowHalfWidth * Math.sin(arrowTailAngle));\n          ctx.fillStyle = arrowColor;\n          ctx.fill();\n        });\n        ctx.restore();\n      }\n      function paintPhotons() {\n        var getNumPhotons = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticles);\n        var getSpeed = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleSpeed);\n        var getOffset = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleOffset);\n        var getDiameter = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleWidth);\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkVisibility);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleColor || state.linkColor);\n        var ctx = state.ctx;\n        ctx.save();\n        state.graphData.links.filter(getVisibility).forEach(function (link) {\n          var numCyclePhotons = getNumPhotons(link);\n          if (!link.hasOwnProperty('__photons') || !link.__photons.length) return;\n          var start = link.source;\n          var end = link.target;\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var particleSpeed = getSpeed(link);\n          var particleOffset = Math.abs(getOffset(link));\n          var photons = link.__photons || [];\n          var photonR = Math.max(0, getDiameter(link) / 2) / Math.sqrt(state.globalScale);\n          var photonColor = getColor(link) || 'rgba(0,0,0,0.28)';\n          ctx.fillStyle = photonColor;\n\n          // Construct bezier for curved lines\n          var bzLine = link.__controlPoints ? _construct(bezier_js__WEBPACK_IMPORTED_MODULE_4__.Bezier, [start.x, start.y].concat(_toConsumableArray(link.__controlPoints), [end.x, end.y])) : null;\n          var cyclePhotonIdx = 0;\n          var needsCleanup = false; // whether some photons need to be removed from list\n          photons.forEach(function (photon) {\n            var singleHop = !!photon.__singleHop;\n            if (!photon.hasOwnProperty('__progressRatio')) {\n              photon.__progressRatio = singleHop ? 0 : (cyclePhotonIdx + particleOffset) / numCyclePhotons;\n            }\n            !singleHop && cyclePhotonIdx++; // increase regular photon index\n\n            photon.__progressRatio += particleSpeed;\n            if (photon.__progressRatio >= 1) {\n              if (!singleHop) {\n                photon.__progressRatio = photon.__progressRatio % 1;\n              } else {\n                needsCleanup = true;\n                return;\n              }\n            }\n            var photonPosRatio = photon.__progressRatio;\n            var coords = bzLine ? bzLine.get(photonPosRatio) // get position along bezier line\n            : {\n              // straight line: interpolate linearly\n              x: start.x + (end.x - start.x) * photonPosRatio || 0,\n              y: start.y + (end.y - start.y) * photonPosRatio || 0\n            };\n            if (state.linkDirectionalParticleCanvasObject) {\n              state.linkDirectionalParticleCanvasObject(coords.x, coords.y, link, ctx, state.globalScale);\n            } else {\n              ctx.beginPath();\n              ctx.arc(coords.x, coords.y, photonR, 0, 2 * Math.PI, false);\n              ctx.fill();\n            }\n          });\n          if (needsCleanup) {\n            // remove expired single hop photons\n            link.__photons = link.__photons.filter(function (photon) {\n              return !photon.__singleHop || photon.__progressRatio <= 1;\n            });\n          }\n        });\n        ctx.restore();\n      }\n    },\n    emitParticle: function emitParticle(state, link) {\n      if (link) {\n        !link.__photons && (link.__photons = []);\n        link.__photons.push({\n          __singleHop: true\n        }); // add a single hop particle\n      }\n      return this;\n    }\n  },\n  stateInit: function stateInit() {\n    return {\n      forceLayout: (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_9__[\"default\"])().force('link', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_10__[\"default\"])()).force('charge', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_11__[\"default\"])()).force('center', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_12__[\"default\"])()).force('dagRadial', null).stop(),\n      engineRunning: false\n    };\n  },\n  init: function init(canvasCtx, state) {\n    // Main canvas object to manipulate\n    state.ctx = canvasCtx;\n  },\n  update: function update(state, changedProps) {\n    state.engineRunning = false; // Pause simulation\n    state.onUpdate();\n    if (state.nodeAutoColorBy !== null) {\n      // Auto add color to uncolored nodes\n      autoColorObjects(state.graphData.nodes, (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeAutoColorBy), state.nodeColor);\n    }\n    if (state.linkAutoColorBy !== null) {\n      // Auto add color to uncolored links\n      autoColorObjects(state.graphData.links, (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkAutoColorBy), state.linkColor);\n    }\n\n    // parse links\n    state.graphData.links.forEach(function (link) {\n      link.source = link[state.linkSource];\n      link.target = link[state.linkTarget];\n    });\n\n    // Feed data to force-directed layout\n    state.forceLayout.stop().alpha(1) // re-heat the simulation\n    .nodes(state.graphData.nodes);\n\n    // add links (if link force is still active)\n    var linkForce = state.forceLayout.force('link');\n    if (linkForce) {\n      linkForce.id(function (d) {\n        return d[state.nodeId];\n      }).links(state.graphData.links);\n    }\n\n    // setup dag force constraints\n    var nodeDepths = state.dagMode && getDagDepths(state.graphData, function (node) {\n      return node[state.nodeId];\n    }, {\n      nodeFilter: state.dagNodeFilter,\n      onLoopError: state.onDagError || undefined\n    });\n    var maxDepth = Math.max.apply(Math, _toConsumableArray(Object.values(nodeDepths || [])));\n    var dagLevelDistance = state.dagLevelDistance || state.graphData.nodes.length / (maxDepth || 1) * DAG_LEVEL_NODE_RATIO * (['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? 0.7 : 1);\n\n    // Reset relevant fx/fy when swapping dag modes\n    if (['lr', 'rl', 'td', 'bu'].includes(changedProps.dagMode)) {\n      var resetProp = ['lr', 'rl'].includes(changedProps.dagMode) ? 'fx' : 'fy';\n      state.graphData.nodes.filter(state.dagNodeFilter).forEach(function (node) {\n        return delete node[resetProp];\n      });\n    }\n\n    // Fix nodes to x,y for dag mode\n    if (['lr', 'rl', 'td', 'bu'].includes(state.dagMode)) {\n      var invert = ['rl', 'bu'].includes(state.dagMode);\n      var fixFn = function fixFn(node) {\n        return (nodeDepths[node[state.nodeId]] - maxDepth / 2) * dagLevelDistance * (invert ? -1 : 1);\n      };\n      var _resetProp = ['lr', 'rl'].includes(state.dagMode) ? 'fx' : 'fy';\n      state.graphData.nodes.filter(state.dagNodeFilter).forEach(function (node) {\n        return node[_resetProp] = fixFn(node);\n      });\n    }\n\n    // Use radial force for radial dags\n    state.forceLayout.force('dagRadial', ['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_13__[\"default\"])(function (node) {\n      var nodeDepth = nodeDepths[node[state.nodeId]] || -1;\n      return (state.dagMode === 'radialin' ? maxDepth - nodeDepth : nodeDepth) * dagLevelDistance;\n    }).strength(function (node) {\n      return state.dagNodeFilter(node) ? 1 : 0;\n    }) : null);\n    for (var i = 0; i < state.warmupTicks && !(state.d3AlphaMin > 0 && state.forceLayout.alpha() < state.d3AlphaMin); i++) {\n      state.forceLayout.tick();\n    } // Initial ticks before starting to render\n\n    this.resetCountdown();\n    state.onFinishUpdate();\n  }\n});\n\nfunction linkKapsule (kapsulePropNames, kapsuleType) {\n  var propNames = kapsulePropNames instanceof Array ? kapsulePropNames : [kapsulePropNames];\n  var dummyK = new kapsuleType(); // To extract defaults\n  dummyK._destructor && dummyK._destructor();\n  return {\n    linkProp: function linkProp(prop) {\n      // link property config\n      return {\n        \"default\": dummyK[prop](),\n        onChange: function onChange(v, state) {\n          propNames.forEach(function (propName) {\n            return state[propName][prop](v);\n          });\n        },\n        triggerUpdate: false\n      };\n    },\n    linkMethod: function linkMethod(method) {\n      // link method pass-through\n      return function (state) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        var returnVals = [];\n        propNames.forEach(function (propName) {\n          var kapsuleInstance = state[propName];\n          var returnVal = kapsuleInstance[method].apply(kapsuleInstance, args);\n          if (returnVal !== kapsuleInstance) {\n            returnVals.push(returnVal);\n          }\n        });\n        return returnVals.length ? returnVals[0] : this; // chain based on the parent object, not the inner kapsule\n      };\n    }\n  };\n}\n\nvar HOVER_CANVAS_THROTTLE_DELAY = 800; // ms to throttle shadow canvas updates for perf improvement\nvar ZOOM2NODES_FACTOR = 4;\nvar DRAG_CLICK_TOLERANCE_PX = 5; // How many px can a node be accidentally dragged before disabling the click\n\n// Expose config from forceGraph\nvar bindFG = linkKapsule('forceGraph', CanvasForceGraph);\nvar bindBoth = linkKapsule(['forceGraph', 'shadowGraph'], CanvasForceGraph);\nvar linkedProps = Object.assign.apply(Object, _toConsumableArray(['nodeColor', 'nodeAutoColorBy', 'nodeCanvasObject', 'nodeCanvasObjectMode', 'linkColor', 'linkAutoColorBy', 'linkLineDash', 'linkWidth', 'linkCanvasObject', 'linkCanvasObjectMode', 'linkDirectionalArrowLength', 'linkDirectionalArrowColor', 'linkDirectionalArrowRelPos', 'linkDirectionalParticles', 'linkDirectionalParticleSpeed', 'linkDirectionalParticleOffset', 'linkDirectionalParticleWidth', 'linkDirectionalParticleColor', 'linkDirectionalParticleCanvasObject', 'dagMode', 'dagLevelDistance', 'dagNodeFilter', 'onDagError', 'd3AlphaMin', 'd3AlphaDecay', 'd3VelocityDecay', 'warmupTicks', 'cooldownTicks', 'cooldownTime', 'onEngineTick', 'onEngineStop'].map(function (p) {\n  return _defineProperty({}, p, bindFG.linkProp(p));\n})).concat(_toConsumableArray(['nodeRelSize', 'nodeId', 'nodeVal', 'nodeVisibility', 'linkSource', 'linkTarget', 'linkVisibility', 'linkCurvature'].map(function (p) {\n  return _defineProperty({}, p, bindBoth.linkProp(p));\n}))));\nvar linkedMethods = Object.assign.apply(Object, _toConsumableArray(['d3Force', 'd3ReheatSimulation', 'emitParticle'].map(function (p) {\n  return _defineProperty({}, p, bindFG.linkMethod(p));\n})));\nfunction adjustCanvasSize(state) {\n  if (state.canvas) {\n    var curWidth = state.canvas.width;\n    var curHeight = state.canvas.height;\n    if (curWidth === 300 && curHeight === 150) {\n      // Default canvas dimensions\n      curWidth = curHeight = 0;\n    }\n    var pxScale = window.devicePixelRatio; // 2 on retina displays\n    curWidth /= pxScale;\n    curHeight /= pxScale;\n\n    // Resize canvases\n    [state.canvas, state.shadowCanvas].forEach(function (canvas) {\n      // Element size\n      canvas.style.width = \"\".concat(state.width, \"px\");\n      canvas.style.height = \"\".concat(state.height, \"px\");\n\n      // Memory size (scaled to avoid blurriness)\n      canvas.width = state.width * pxScale;\n      canvas.height = state.height * pxScale;\n\n      // Normalize coordinate system to use css pixels (on init only)\n      if (!curWidth && !curHeight) {\n        canvas.getContext('2d').scale(pxScale, pxScale);\n      }\n    });\n\n    // Relative center panning based on 0,0\n    var k = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n    state.zoom.translateBy(state.zoom.__baseElem, (state.width - curWidth) / 2 / k, (state.height - curHeight) / 2 / k);\n    state.needsRedraw = true;\n  }\n}\nfunction resetTransform(ctx) {\n  var pxRatio = window.devicePixelRatio;\n  ctx.setTransform(pxRatio, 0, 0, pxRatio, 0, 0);\n}\nfunction clearCanvas(ctx, width, height) {\n  ctx.save();\n  resetTransform(ctx); // reset transform\n  ctx.clearRect(0, 0, width, height);\n  ctx.restore(); //restore transforms\n}\n\n//\n\nvar forceGraph = (0,kapsule__WEBPACK_IMPORTED_MODULE_7__[\"default\"])({\n  props: _objectSpread2({\n    width: {\n      \"default\": window.innerWidth,\n      onChange: function onChange(_, state) {\n        return adjustCanvasSize(state);\n      },\n      triggerUpdate: false\n    },\n    height: {\n      \"default\": window.innerHeight,\n      onChange: function onChange(_, state) {\n        return adjustCanvasSize(state);\n      },\n      triggerUpdate: false\n    },\n    graphData: {\n      \"default\": {\n        nodes: [],\n        links: []\n      },\n      onChange: function onChange(d, state) {\n        // Wipe color registry if all objects are new\n        [d.nodes, d.links].every(function (arr) {\n          return (arr || []).every(function (d) {\n            return !d.hasOwnProperty('__indexColor');\n          });\n        }) && state.colorTracker.reset();\n        [{\n          type: 'Node',\n          objs: d.nodes\n        }, {\n          type: 'Link',\n          objs: d.links\n        }].forEach(hexIndex);\n        state.forceGraph.graphData(d);\n        state.shadowGraph.graphData(d);\n        function hexIndex(_ref4) {\n          var type = _ref4.type,\n            objs = _ref4.objs;\n          objs.filter(function (d) {\n            if (!d.hasOwnProperty('__indexColor')) return true;\n            var cur = state.colorTracker.lookup(d.__indexColor);\n            return !cur || !cur.hasOwnProperty('d') || cur.d !== d;\n          }).forEach(function (d) {\n            // store object lookup color\n            d.__indexColor = state.colorTracker.register({\n              type: type,\n              d: d\n            });\n          });\n        }\n      },\n      triggerUpdate: false\n    },\n    backgroundColor: {\n      onChange: function onChange(color, state) {\n        state.canvas && color && (state.canvas.style.background = color);\n      },\n      triggerUpdate: false\n    },\n    nodeLabel: {\n      \"default\": 'name',\n      triggerUpdate: false\n    },\n    nodePointerAreaPaint: {\n      onChange: function onChange(paintFn, state) {\n        state.shadowGraph.nodeCanvasObject(!paintFn ? null : function (node, ctx, globalScale) {\n          return paintFn(node, node.__indexColor, ctx, globalScale);\n        });\n        state.flushShadowCanvas && state.flushShadowCanvas();\n      },\n      triggerUpdate: false\n    },\n    linkPointerAreaPaint: {\n      onChange: function onChange(paintFn, state) {\n        state.shadowGraph.linkCanvasObject(!paintFn ? null : function (link, ctx, globalScale) {\n          return paintFn(link, link.__indexColor, ctx, globalScale);\n        });\n        state.flushShadowCanvas && state.flushShadowCanvas();\n      },\n      triggerUpdate: false\n    },\n    linkLabel: {\n      \"default\": 'name',\n      triggerUpdate: false\n    },\n    linkHoverPrecision: {\n      \"default\": 4,\n      triggerUpdate: false\n    },\n    minZoom: {\n      \"default\": 0.01,\n      onChange: function onChange(minZoom, state) {\n        state.zoom.scaleExtent([minZoom, state.zoom.scaleExtent()[1]]);\n      },\n      triggerUpdate: false\n    },\n    maxZoom: {\n      \"default\": 1000,\n      onChange: function onChange(maxZoom, state) {\n        state.zoom.scaleExtent([state.zoom.scaleExtent()[0], maxZoom]);\n      },\n      triggerUpdate: false\n    },\n    enableNodeDrag: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    enableZoomInteraction: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    enablePanInteraction: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    enableZoomPanInteraction: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    // to be deprecated\n    enablePointerInteraction: {\n      \"default\": true,\n      onChange: function onChange(_, state) {\n        state.hoverObj = null;\n      },\n      triggerUpdate: false\n    },\n    autoPauseRedraw: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    onNodeDrag: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onNodeDragEnd: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onNodeClick: {\n      triggerUpdate: false\n    },\n    onNodeRightClick: {\n      triggerUpdate: false\n    },\n    onNodeHover: {\n      triggerUpdate: false\n    },\n    onLinkClick: {\n      triggerUpdate: false\n    },\n    onLinkRightClick: {\n      triggerUpdate: false\n    },\n    onLinkHover: {\n      triggerUpdate: false\n    },\n    onBackgroundClick: {\n      triggerUpdate: false\n    },\n    onBackgroundRightClick: {\n      triggerUpdate: false\n    },\n    showPointerCursor: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    onZoom: {\n      triggerUpdate: false\n    },\n    onZoomEnd: {\n      triggerUpdate: false\n    },\n    onRenderFramePre: {\n      triggerUpdate: false\n    },\n    onRenderFramePost: {\n      triggerUpdate: false\n    }\n  }, linkedProps),\n  aliases: {\n    // Prop names supported for backwards compatibility\n    stopAnimation: 'pauseAnimation'\n  },\n  methods: _objectSpread2({\n    graph2ScreenCoords: function graph2ScreenCoords(state, x, y) {\n      var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n      return {\n        x: x * t.k + t.x,\n        y: y * t.k + t.y\n      };\n    },\n    screen2GraphCoords: function screen2GraphCoords(state, x, y) {\n      var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n      return {\n        x: (x - t.x) / t.k,\n        y: (y - t.y) / t.k\n      };\n    },\n    centerAt: function centerAt(state, x, y, transitionDuration) {\n      if (!state.canvas) return null; // no canvas yet\n\n      // setter\n      if (x !== undefined || y !== undefined) {\n        var finalPos = Object.assign({}, x !== undefined ? {\n          x: x\n        } : {}, y !== undefined ? {\n          y: y\n        } : {});\n        if (!transitionDuration) {\n          // no animation\n          setCenter(finalPos);\n        } else {\n          state.tweenGroup.add(new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Tween(getCenter()).to(finalPos, transitionDuration).easing(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Easing.Quadratic.Out).onUpdate(setCenter).start());\n        }\n        return this;\n      }\n\n      // getter\n      return getCenter();\n\n      //\n\n      function getCenter() {\n        var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n        return {\n          x: (state.width / 2 - t.x) / t.k,\n          y: (state.height / 2 - t.y) / t.k\n        };\n      }\n      function setCenter(_ref5) {\n        var x = _ref5.x,\n          y = _ref5.y;\n        state.zoom.translateTo(state.zoom.__baseElem, x === undefined ? getCenter().x : x, y === undefined ? getCenter().y : y);\n        state.needsRedraw = true;\n      }\n    },\n    zoom: function zoom(state, k, transitionDuration) {\n      if (!state.canvas) return null; // no canvas yet\n\n      // setter\n      if (k !== undefined) {\n        if (!transitionDuration) {\n          // no animation\n          setZoom(k);\n        } else {\n          state.tweenGroup.add(new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Tween({\n            k: getZoom()\n          }).to({\n            k: k\n          }, transitionDuration).easing(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Easing.Quadratic.Out).onUpdate(function (_ref6) {\n            var k = _ref6.k;\n            return setZoom(k);\n          }).start());\n        }\n        return this;\n      }\n\n      // getter\n      return getZoom();\n\n      //\n\n      function getZoom() {\n        return (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n      }\n      function setZoom(k) {\n        state.zoom.scaleTo(state.zoom.__baseElem, k);\n        state.needsRedraw = true;\n      }\n    },\n    zoomToFit: function zoomToFit(state) {\n      var transitionDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n      for (var _len = arguments.length, bboxArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        bboxArgs[_key - 3] = arguments[_key];\n      }\n      var bbox = this.getGraphBbox.apply(this, bboxArgs);\n      if (bbox) {\n        var center = {\n          x: (bbox.x[0] + bbox.x[1]) / 2,\n          y: (bbox.y[0] + bbox.y[1]) / 2\n        };\n        var zoomK = Math.max(1e-12, Math.min(1e12, (state.width - padding * 2) / (bbox.x[1] - bbox.x[0]), (state.height - padding * 2) / (bbox.y[1] - bbox.y[0])));\n        this.centerAt(center.x, center.y, transitionDuration);\n        this.zoom(zoomK, transitionDuration);\n      }\n      return this;\n    },\n    getGraphBbox: function getGraphBbox(state) {\n      var nodeFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n      var getVal = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n      var getR = function getR(node) {\n        return Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize;\n      };\n      var nodesPos = state.graphData.nodes.filter(nodeFilter).map(function (node) {\n        return {\n          x: node.x,\n          y: node.y,\n          r: getR(node)\n        };\n      });\n      return !nodesPos.length ? null : {\n        x: [(0,d3_array__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(nodesPos, function (node) {\n          return node.x - node.r;\n        }), (0,d3_array__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(nodesPos, function (node) {\n          return node.x + node.r;\n        })],\n        y: [(0,d3_array__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(nodesPos, function (node) {\n          return node.y - node.r;\n        }), (0,d3_array__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(nodesPos, function (node) {\n          return node.y + node.r;\n        })]\n      };\n    },\n    pauseAnimation: function pauseAnimation(state) {\n      if (state.animationFrameRequestId) {\n        cancelAnimationFrame(state.animationFrameRequestId);\n        state.animationFrameRequestId = null;\n      }\n      return this;\n    },\n    resumeAnimation: function resumeAnimation(state) {\n      if (!state.animationFrameRequestId) {\n        this._animationCycle();\n      }\n      return this;\n    },\n    _destructor: function _destructor() {\n      this.pauseAnimation();\n      this.graphData({\n        nodes: [],\n        links: []\n      });\n    }\n  }, linkedMethods),\n  stateInit: function stateInit() {\n    return {\n      lastSetZoom: 1,\n      zoom: (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)(),\n      forceGraph: new CanvasForceGraph(),\n      shadowGraph: new CanvasForceGraph().cooldownTicks(0).nodeColor('__indexColor').linkColor('__indexColor').isShadow(true),\n      colorTracker: new canvas_color_tracker__WEBPACK_IMPORTED_MODULE_16__[\"default\"](),\n      // indexed objects for rgb lookup\n      tweenGroup: new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Group()\n    };\n  },\n  init: function init(domNode, state) {\n    var _this = this;\n    // Wipe DOM\n    domNode.innerHTML = '';\n\n    // Container anchor for canvas and tooltip\n    var container = document.createElement('div');\n    container.classList.add('force-graph-container');\n    container.style.position = 'relative';\n    domNode.appendChild(container);\n    state.canvas = document.createElement('canvas');\n    if (state.backgroundColor) state.canvas.style.background = state.backgroundColor;\n    container.appendChild(state.canvas);\n    state.shadowCanvas = document.createElement('canvas');\n\n    // Show shadow canvas\n    //state.shadowCanvas.style.position = 'absolute';\n    //state.shadowCanvas.style.top = '0';\n    //state.shadowCanvas.style.left = '0';\n    //container.appendChild(state.shadowCanvas);\n\n    var ctx = state.canvas.getContext('2d');\n    var shadowCtx = state.shadowCanvas.getContext('2d', {\n      willReadFrequently: true\n    });\n    var pointerPos = {\n      x: -1e12,\n      y: -1e12\n    };\n    var getObjUnderPointer = function getObjUnderPointer() {\n      var obj = null;\n      var pxScale = window.devicePixelRatio;\n      var px = pointerPos.x > 0 && pointerPos.y > 0 ? shadowCtx.getImageData(pointerPos.x * pxScale, pointerPos.y * pxScale, 1, 1) : null;\n      // Lookup object per pixel color\n      px && (obj = state.colorTracker.lookup(px.data));\n      return obj;\n    };\n\n    // Setup node drag interaction\n    (0,d3_selection__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(state.canvas).call((0,d3_drag__WEBPACK_IMPORTED_MODULE_18__[\"default\"])().subject(function () {\n      if (!state.enableNodeDrag) {\n        return null;\n      }\n      var obj = getObjUnderPointer();\n      return obj && obj.type === 'Node' ? obj.d : null; // Only drag nodes\n    }).on('start', function (ev) {\n      var obj = ev.subject;\n      obj.__initialDragPos = {\n        x: obj.x,\n        y: obj.y,\n        fx: obj.fx,\n        fy: obj.fy\n      };\n\n      // keep engine running at low intensity throughout drag\n      if (!ev.active) {\n        obj.fx = obj.x;\n        obj.fy = obj.y; // Fix points\n      }\n\n      // drag cursor\n      state.canvas.classList.add('grabbable');\n    }).on('drag', function (ev) {\n      var obj = ev.subject;\n      var initPos = obj.__initialDragPos;\n      var dragPos = ev;\n      var k = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n      var translate = {\n        x: initPos.x + (dragPos.x - initPos.x) / k - obj.x,\n        y: initPos.y + (dragPos.y - initPos.y) / k - obj.y\n      };\n\n      // Move fx/fy (and x/y) of nodes based on the scaled drag distance since the drag start\n      ['x', 'y'].forEach(function (c) {\n        return obj[\"f\".concat(c)] = obj[c] = initPos[c] + (dragPos[c] - initPos[c]) / k;\n      });\n\n      // Only engage full drag if distance reaches above threshold\n      if (!obj.__dragged && DRAG_CLICK_TOLERANCE_PX >= Math.sqrt((0,d3_array__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(['x', 'y'].map(function (k) {\n        return Math.pow(ev[k] - initPos[k], 2);\n      })))) return;\n      state.forceGraph.d3AlphaTarget(0.3) // keep engine running at low intensity throughout drag\n      .resetCountdown(); // prevent freeze while dragging\n\n      state.isPointerDragging = true;\n      obj.__dragged = true;\n      state.onNodeDrag(obj, translate);\n    }).on('end', function (ev) {\n      var obj = ev.subject;\n      var initPos = obj.__initialDragPos;\n      var translate = {\n        x: obj.x - initPos.x,\n        y: obj.y - initPos.y\n      };\n      if (initPos.fx === undefined) {\n        obj.fx = undefined;\n      }\n      if (initPos.fy === undefined) {\n        obj.fy = undefined;\n      }\n      delete obj.__initialDragPos;\n      if (state.forceGraph.d3AlphaTarget()) {\n        state.forceGraph.d3AlphaTarget(0) // release engine low intensity\n        .resetCountdown(); // let the engine readjust after releasing fixed nodes\n      }\n\n      // drag cursor\n      state.canvas.classList.remove('grabbable');\n      state.isPointerDragging = false;\n      if (obj.__dragged) {\n        delete obj.__dragged;\n        state.onNodeDragEnd(obj, translate);\n      }\n    }));\n\n    // Setup zoom / pan interaction\n    state.zoom(state.zoom.__baseElem = (0,d3_selection__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(state.canvas)); // Attach controlling elem for easy access\n\n    state.zoom.__baseElem.on('dblclick.zoom', null); // Disable double-click to zoom\n\n    state.zoom.filter(function (ev) {\n      return (\n        // disable zoom interaction\n        !ev.button && state.enableZoomPanInteraction && (ev.type !== 'wheel' || (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.enableZoomInteraction)(ev)) && (ev.type === 'wheel' || (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.enablePanInteraction)(ev))\n      );\n    }).on('zoom', function (ev) {\n      var t = ev.transform;\n      [ctx, shadowCtx].forEach(function (c) {\n        resetTransform(c);\n        c.translate(t.x, t.y);\n        c.scale(t.k, t.k);\n      });\n      state.isPointerDragging = true;\n      state.onZoom && state.onZoom(_objectSpread2(_objectSpread2({}, t), _this.centerAt())); // report x,y coordinates relative to canvas center\n      state.needsRedraw = true;\n    }).on('end', function (ev) {\n      state.isPointerDragging = false;\n      state.onZoomEnd && state.onZoomEnd(_objectSpread2(_objectSpread2({}, ev.transform), _this.centerAt()));\n    });\n    adjustCanvasSize(state);\n    state.forceGraph.onNeedsRedraw(function () {\n      return state.needsRedraw = true;\n    }).onFinishUpdate(function () {\n      // re-zoom, if still in default position (not user modified)\n      if ((0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k === state.lastSetZoom && state.graphData.nodes.length) {\n        state.zoom.scaleTo(state.zoom.__baseElem, state.lastSetZoom = ZOOM2NODES_FACTOR / Math.cbrt(state.graphData.nodes.length));\n        state.needsRedraw = true;\n      }\n    });\n\n    // Setup tooltip\n    state.tooltip = new float_tooltip__WEBPACK_IMPORTED_MODULE_3__[\"default\"](container);\n\n    // Capture pointer coords on move or touchstart\n    ['pointermove', 'pointerdown'].forEach(function (evType) {\n      return container.addEventListener(evType, function (ev) {\n        if (evType === 'pointerdown') {\n          state.isPointerPressed = true; // track click state\n          state.pointerDownEvent = ev;\n        }\n\n        // detect pointer drag on canvas pan\n        !state.isPointerDragging && ev.type === 'pointermove' && state.onBackgroundClick // only bother detecting drags this way if background clicks are enabled (so they don't trigger accidentally on canvas panning)\n        && (ev.pressure > 0 || state.isPointerPressed) // ev.pressure always 0 on Safari, so we use the isPointerPressed tracker\n        && (ev.pointerType === 'mouse' || ev.movementX === undefined || [ev.movementX, ev.movementY].some(function (m) {\n          return Math.abs(m) > 1;\n        })) // relax drag trigger sensitivity on non-mouse (touch/pen) events\n        && (state.isPointerDragging = true);\n\n        // update the pointer pos\n        var offset = getOffset(container);\n        pointerPos.x = ev.pageX - offset.left;\n        pointerPos.y = ev.pageY - offset.top;\n\n        //\n\n        function getOffset(el) {\n          var rect = el.getBoundingClientRect(),\n            scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,\n            scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n          return {\n            top: rect.top + scrollTop,\n            left: rect.left + scrollLeft\n          };\n        }\n      }, {\n        passive: true\n      });\n    });\n\n    // Handle click/touch events on nodes/links\n    container.addEventListener('pointerup', function (ev) {\n      if (!state.isPointerPressed) {\n        return; // don't trigger click events if pointer is not pressed on the canvas\n      }\n      state.isPointerPressed = false;\n      if (state.isPointerDragging) {\n        state.isPointerDragging = false;\n        return; // don't trigger click events after pointer drag (pan / node drag functionality)\n      }\n      var cbEvents = [ev, state.pointerDownEvent];\n      requestAnimationFrame(function () {\n        // trigger click events asynchronously, to allow hoverObj to be set (on frame)\n        if (ev.button === 0) {\n          // mouse left-click or touch\n          if (state.hoverObj) {\n            var fn = state[\"on\".concat(state.hoverObj.type, \"Click\")];\n            fn && fn.apply(void 0, [state.hoverObj.d].concat(cbEvents));\n          } else {\n            state.onBackgroundClick && state.onBackgroundClick.apply(state, cbEvents);\n          }\n        }\n        if (ev.button === 2) {\n          // mouse right-click\n          if (state.hoverObj) {\n            var _fn = state[\"on\".concat(state.hoverObj.type, \"RightClick\")];\n            _fn && _fn.apply(void 0, [state.hoverObj.d].concat(cbEvents));\n          } else {\n            state.onBackgroundRightClick && state.onBackgroundRightClick.apply(state, cbEvents);\n          }\n        }\n      });\n    }, {\n      passive: true\n    });\n    container.addEventListener('contextmenu', function (ev) {\n      if (!state.onBackgroundRightClick && !state.onNodeRightClick && !state.onLinkRightClick) return true; // default contextmenu behavior\n      ev.preventDefault();\n      return false;\n    });\n    state.forceGraph(ctx);\n    state.shadowGraph(shadowCtx);\n\n    //\n\n    var refreshShadowCanvas = (0,lodash_es__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(function () {\n      // wipe canvas\n      clearCanvas(shadowCtx, state.width, state.height);\n\n      // Adjust link hover area\n      state.shadowGraph.linkWidth(function (l) {\n        return (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkWidth)(l) + state.linkHoverPrecision;\n      });\n\n      // redraw\n      var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n      state.shadowGraph.globalScale(t.k).tickFrame();\n    }, HOVER_CANVAS_THROTTLE_DELAY);\n    state.flushShadowCanvas = refreshShadowCanvas.flush; // hook to immediately invoke shadow canvas paint\n\n    // Kick-off renderer\n    (this._animationCycle = function animate() {\n      // IIFE\n      var doRedraw = !state.autoPauseRedraw || !!state.needsRedraw || state.forceGraph.isEngineRunning() || state.graphData.links.some(function (d) {\n        return d.__photons && d.__photons.length;\n      });\n      state.needsRedraw = false;\n      if (state.enablePointerInteraction) {\n        // Update tooltip and trigger onHover events\n        var obj = !state.isPointerDragging ? getObjUnderPointer() : null; // don't hover during drag\n        if (obj !== state.hoverObj) {\n          var prevObj = state.hoverObj;\n          var prevObjType = prevObj ? prevObj.type : null;\n          var objType = obj ? obj.type : null;\n          if (prevObjType && prevObjType !== objType) {\n            // Hover out\n            var fn = state[\"on\".concat(prevObjType, \"Hover\")];\n            fn && fn(null, prevObj.d);\n          }\n          if (objType) {\n            // Hover in\n            var _fn2 = state[\"on\".concat(objType, \"Hover\")];\n            _fn2 && _fn2(obj.d, prevObjType === objType ? prevObj.d : null);\n          }\n          state.tooltip.content(obj ? (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state[\"\".concat(obj.type.toLowerCase(), \"Label\")])(obj.d) || null : null);\n\n          // set pointer if hovered object is clickable\n          state.canvas.classList[(obj && state[\"on\".concat(objType, \"Click\")] || !obj && state.onBackgroundClick) && (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.showPointerCursor)(obj === null || obj === void 0 ? void 0 : obj.d) ? 'add' : 'remove']('clickable');\n          state.hoverObj = obj;\n        }\n        doRedraw && refreshShadowCanvas();\n      }\n      if (doRedraw) {\n        // Wipe canvas\n        clearCanvas(ctx, state.width, state.height);\n\n        // Frame cycle\n        var globalScale = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n        state.onRenderFramePre && state.onRenderFramePre(ctx, globalScale);\n        state.forceGraph.globalScale(globalScale).tickFrame();\n        state.onRenderFramePost && state.onRenderFramePost(ctx, globalScale);\n      }\n      state.tweenGroup.update(); // update canvas animation tweens\n\n      state.animationFrameRequestId = requestAnimationFrame(animate);\n    })();\n  },\n  update: function updateFn(state) {}\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9yY2UtZ3JhcGgvZGlzdC9mb3JjZS1ncmFwaC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzQztBQUNRO0FBQ2Y7QUFDVTtBQUNKO0FBQ29CO0FBQzNCO0FBQ087QUFDVztBQUNaO0FBQzhEO0FBQy9EO0FBQ0U7QUFDRztBQUNVOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLG1CQUFtQixzQkFBc0Isa0JBQWtCLDZDQUE2QyxHQUFHLHVDQUF1QyxvQkFBb0IsR0FBRyx1Q0FBdUMsaUJBQWlCLGlCQUFpQixzQkFBc0IseUJBQXlCLEdBQUcsOENBQThDLHFCQUFxQiwwQkFBMEIsNkJBQTZCLEdBQUc7QUFDaGQ7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekYsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVksa0VBQWtFO0FBQzdILE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsWUFBWTtBQUNaLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtB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LDBCQUEwQixzREFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXJlZXItZ3BzLXByb3RvLy4vbm9kZV9tb2R1bGVzL2ZvcmNlLWdyYXBoL2Rpc3QvZm9yY2UtZ3JhcGgubWpzPzg5YWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJztcbmltcG9ydCB7IHpvb21UcmFuc2Zvcm0sIHpvb20gfSBmcm9tICdkMy16b29tJztcbmltcG9ydCB7IGRyYWcgfSBmcm9tICdkMy1kcmFnJztcbmltcG9ydCB7IHN1bSwgbWluLCBtYXggfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgeyB0aHJvdHRsZSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBHcm91cCwgVHdlZW4sIEVhc2luZyB9IGZyb20gJ0B0d2VlbmpzL3R3ZWVuLmpzJztcbmltcG9ydCBLYXBzdWxlIGZyb20gJ2thcHN1bGUnO1xuaW1wb3J0IGFjY2Vzc29yRm4gZnJvbSAnYWNjZXNzb3ItZm4nO1xuaW1wb3J0IENvbG9yVHJhY2tlciBmcm9tICdjYW52YXMtY29sb3ItdHJhY2tlcic7XG5pbXBvcnQgVG9vbHRpcCBmcm9tICdmbG9hdC10b29sdGlwJztcbmltcG9ydCB7IGZvcmNlUmFkaWFsLCBmb3JjZVNpbXVsYXRpb24sIGZvcmNlTGluaywgZm9yY2VNYW55Qm9keSwgZm9yY2VDZW50ZXIgfSBmcm9tICdkMy1mb3JjZS0zZCc7XG5pbXBvcnQgeyBCZXppZXIgfSBmcm9tICdiZXppZXItanMnO1xuaW1wb3J0IGluZGV4QnkgZnJvbSAnaW5kZXgtYXJyYXktYnknO1xuaW1wb3J0IHsgc2NhbGVPcmRpbmFsIH0gZnJvbSAnZDMtc2NhbGUnO1xuaW1wb3J0IHsgc2NoZW1lUGFpcmVkIH0gZnJvbSAnZDMtc2NhbGUtY2hyb21hdGljJztcblxuZnVuY3Rpb24gc3R5bGVJbmplY3QoY3NzLCByZWYpIHtcbiAgaWYgKHJlZiA9PT0gdm9pZCAwKSByZWYgPSB7fTtcbiAgdmFyIGluc2VydEF0ID0gcmVmLmluc2VydEF0O1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gIGlmIChpbnNlcnRBdCA9PT0gJ3RvcCcpIHtcbiAgICBpZiAoaGVhZC5maXJzdENoaWxkKSB7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZSwgaGVhZC5maXJzdENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBjc3NfMjQ4eiA9IFwiLmZvcmNlLWdyYXBoLWNvbnRhaW5lciBjYW52YXMge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIG91dGxpbmU6IG5vbmU7XFxuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG5cXG4uZm9yY2UtZ3JhcGgtY29udGFpbmVyIC5jbGlja2FibGUge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4uZm9yY2UtZ3JhcGgtY29udGFpbmVyIC5ncmFiYmFibGUge1xcbiAgY3Vyc29yOiBtb3ZlO1xcbiAgY3Vyc29yOiBncmFiO1xcbiAgY3Vyc29yOiAtbW96LWdyYWI7XFxuICBjdXJzb3I6IC13ZWJraXQtZ3JhYjtcXG59XFxuXFxuLmZvcmNlLWdyYXBoLWNvbnRhaW5lciAuZ3JhYmJhYmxlOmFjdGl2ZSB7XFxuICBjdXJzb3I6IGdyYWJiaW5nO1xcbiAgY3Vyc29yOiAtbW96LWdyYWJiaW5nO1xcbiAgY3Vyc29yOiAtd2Via2l0LWdyYWJiaW5nO1xcbn1cXG5cIjtcbnN0eWxlSW5qZWN0KGNzc18yNDh6KTtcblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkge1xuICAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7XG4gIGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkocik7XG59XG5mdW5jdGlvbiBfY29uc3RydWN0KHQsIGUsIHIpIHtcbiAgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgcmV0dXJuIFJlZmxlY3QuY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHZhciBvID0gW251bGxdO1xuICBvLnB1c2guYXBwbHkobywgZSk7XG4gIHZhciBwID0gbmV3ICh0LmJpbmQuYXBwbHkodCwgbykpKCk7XG4gIHJldHVybiBwO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHtcbiAgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwge1xuICAgIHZhbHVlOiB0LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pIDogZVtyXSA9IHQsIGU7XG59XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICB0cnkge1xuICAgIHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgfSBjYXRjaCAodCkge31cbiAgcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXQ7XG4gIH0pKCk7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KHIpIHtcbiAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBudWxsICE9IHJbU3ltYm9sLml0ZXJhdG9yXSB8fCBudWxsICE9IHJbXCJAQGl0ZXJhdG9yXCJdKSByZXR1cm4gQXJyYXkuZnJvbShyKTtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7XG4gIHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChudWxsICE9IHQpIHtcbiAgICB2YXIgZSxcbiAgICAgIG4sXG4gICAgICBpLFxuICAgICAgdSxcbiAgICAgIGEgPSBbXSxcbiAgICAgIGYgPSB0cnVlLFxuICAgICAgbyA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSA7IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7XG4gICAgfSBjYXRjaCAocikge1xuICAgICAgbyA9IHRydWUsIG4gPSByO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWYgJiYgbnVsbCAhPSB0LnJldHVybiAmJiAodSA9IHQucmV0dXJuKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChvKSB0aHJvdyBuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkocikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXkocikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiO1xufVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7XG4gIGlmIChyKSB7XG4gICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTtcbiAgICB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpO1xuICAgIHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwO1xuICB9XG59XG5cbnZhciBhdXRvQ29sb3JTY2FsZSA9IHNjYWxlT3JkaW5hbChzY2hlbWVQYWlyZWQpO1xuXG4vLyBBdXRvc2V0IGF0dHJpYnV0ZSBjb2xvckZpZWxkIGJ5IGNvbG9yQnlBY2Nlc3NvciBwcm9wZXJ0eVxuLy8gSWYgYW4gb2JqZWN0IGhhcyBhbHJlYWR5IGEgY29sb3IsIGRvbid0IHNldCBpdFxuLy8gT2JqZWN0cyBjYW4gYmUgbm9kZXMgb3IgbGlua3NcbmZ1bmN0aW9uIGF1dG9Db2xvck9iamVjdHMob2JqZWN0cywgY29sb3JCeUFjY2Vzc29yLCBjb2xvckZpZWxkKSB7XG4gIGlmICghY29sb3JCeUFjY2Vzc29yIHx8IHR5cGVvZiBjb2xvckZpZWxkICE9PSAnc3RyaW5nJykgcmV0dXJuO1xuICBvYmplY3RzLmZpbHRlcihmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuICFvYmpbY29sb3JGaWVsZF07XG4gIH0pLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgIG9ialtjb2xvckZpZWxkXSA9IGF1dG9Db2xvclNjYWxlKGNvbG9yQnlBY2Nlc3NvcihvYmopKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldERhZ0RlcHRocyAoX3JlZiwgaWRBY2Nlc3Nvcikge1xuICB2YXIgbm9kZXMgPSBfcmVmLm5vZGVzLFxuICAgIGxpbmtzID0gX3JlZi5saW5rcztcbiAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICBfcmVmMiRub2RlRmlsdGVyID0gX3JlZjIubm9kZUZpbHRlcixcbiAgICBub2RlRmlsdGVyID0gX3JlZjIkbm9kZUZpbHRlciA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSA6IF9yZWYyJG5vZGVGaWx0ZXIsXG4gICAgX3JlZjIkb25Mb29wRXJyb3IgPSBfcmVmMi5vbkxvb3BFcnJvcixcbiAgICBvbkxvb3BFcnJvciA9IF9yZWYyJG9uTG9vcEVycm9yID09PSB2b2lkIDAgPyBmdW5jdGlvbiAobG9vcElkcykge1xuICAgICAgdGhyb3cgXCJJbnZhbGlkIERBRyBzdHJ1Y3R1cmUhIEZvdW5kIGN5Y2xlIGluIG5vZGUgcGF0aDogXCIuY29uY2F0KGxvb3BJZHMuam9pbignIC0+ICcpLCBcIi5cIik7XG4gICAgfSA6IF9yZWYyJG9uTG9vcEVycm9yO1xuICAvLyBsaW5rZWQgZ3JhcGhcbiAgdmFyIGdyYXBoID0ge307XG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gZ3JhcGhbaWRBY2Nlc3Nvcihub2RlKV0gPSB7XG4gICAgICBkYXRhOiBub2RlLFxuICAgICAgb3V0OiBbXSxcbiAgICAgIGRlcHRoOiAtMSxcbiAgICAgIHNraXA6ICFub2RlRmlsdGVyKG5vZGUpXG4gICAgfTtcbiAgfSk7XG4gIGxpbmtzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgdmFyIHNvdXJjZSA9IF9yZWYzLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYzLnRhcmdldDtcbiAgICB2YXIgc291cmNlSWQgPSBnZXROb2RlSWQoc291cmNlKTtcbiAgICB2YXIgdGFyZ2V0SWQgPSBnZXROb2RlSWQodGFyZ2V0KTtcbiAgICBpZiAoIWdyYXBoLmhhc093blByb3BlcnR5KHNvdXJjZUlkKSkgdGhyb3cgXCJNaXNzaW5nIHNvdXJjZSBub2RlIHdpdGggaWQ6IFwiLmNvbmNhdChzb3VyY2VJZCk7XG4gICAgaWYgKCFncmFwaC5oYXNPd25Qcm9wZXJ0eSh0YXJnZXRJZCkpIHRocm93IFwiTWlzc2luZyB0YXJnZXQgbm9kZSB3aXRoIGlkOiBcIi5jb25jYXQodGFyZ2V0SWQpO1xuICAgIHZhciBzb3VyY2VOb2RlID0gZ3JhcGhbc291cmNlSWRdO1xuICAgIHZhciB0YXJnZXROb2RlID0gZ3JhcGhbdGFyZ2V0SWRdO1xuICAgIHNvdXJjZU5vZGUub3V0LnB1c2godGFyZ2V0Tm9kZSk7XG4gICAgZnVuY3Rpb24gZ2V0Tm9kZUlkKG5vZGUpIHtcbiAgICAgIHJldHVybiBfdHlwZW9mKG5vZGUpID09PSAnb2JqZWN0JyA/IGlkQWNjZXNzb3Iobm9kZSkgOiBub2RlO1xuICAgIH1cbiAgfSk7XG4gIHZhciBmb3VuZExvb3BzID0gW107XG4gIHRyYXZlcnNlKE9iamVjdC52YWx1ZXMoZ3JhcGgpKTtcbiAgdmFyIG5vZGVEZXB0aHMgPSBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgW3t9XS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KE9iamVjdC5lbnRyaWVzKGdyYXBoKS5maWx0ZXIoZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgdmFyIF9yZWY1ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjQsIDIpLFxuICAgICAgbm9kZSA9IF9yZWY1WzFdO1xuICAgIHJldHVybiAhbm9kZS5za2lwO1xuICB9KS5tYXAoZnVuY3Rpb24gKF9yZWY2KSB7XG4gICAgdmFyIF9yZWY3ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjYsIDIpLFxuICAgICAgaWQgPSBfcmVmN1swXSxcbiAgICAgIG5vZGUgPSBfcmVmN1sxXTtcbiAgICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBpZCwgbm9kZS5kZXB0aCk7XG4gIH0pKSkpO1xuICByZXR1cm4gbm9kZURlcHRocztcbiAgZnVuY3Rpb24gdHJhdmVyc2Uobm9kZXMpIHtcbiAgICB2YXIgbm9kZVN0YWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICB2YXIgY3VycmVudERlcHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmIChub2RlU3RhY2suaW5kZXhPZihub2RlKSAhPT0gLTEpIHtcbiAgICAgICAgdmFyIGxvb3AgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG5vZGVTdGFjay5zbGljZShub2RlU3RhY2suaW5kZXhPZihub2RlKSkpLCBbbm9kZV0pLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBpZEFjY2Vzc29yKGQuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWZvdW5kTG9vcHMuc29tZShmdW5jdGlvbiAoZm91bmRMb29wKSB7XG4gICAgICAgICAgcmV0dXJuIGZvdW5kTG9vcC5sZW5ndGggPT09IGxvb3AubGVuZ3RoICYmIGZvdW5kTG9vcC5ldmVyeShmdW5jdGlvbiAoaWQsIGlkeCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkID09PSBsb29wW2lkeF07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgZm91bmRMb29wcy5wdXNoKGxvb3ApO1xuICAgICAgICAgIG9uTG9vcEVycm9yKGxvb3ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxOyAvLyBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnREZXB0aCA+IG5vZGUuZGVwdGgpIHtcbiAgICAgICAgLy8gRG9uJ3QgdW5uZWNlc3NhcmlseSByZXZpc2l0IGNodW5rcyBvZiB0aGUgZ3JhcGhcbiAgICAgICAgbm9kZS5kZXB0aCA9IGN1cnJlbnREZXB0aDtcbiAgICAgICAgdHJhdmVyc2Uobm9kZS5vdXQsIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobm9kZVN0YWNrKSwgW25vZGVdKSwgY3VycmVudERlcHRoICsgKG5vZGUuc2tpcCA/IDAgOiAxKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKF9sb29wKCkpIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxufVxuXG4vL1xuXG52YXIgREFHX0xFVkVMX05PREVfUkFUSU8gPSAyO1xuXG4vLyB3aGVuZXZlciBzdHlsaW5nIHByb3BzIGFyZSBjaGFuZ2VkIHRoYXQgcmVxdWlyZSBhIGNhbnZhcyByZWRyYXdcbnZhciBub3RpZnlSZWRyYXcgPSBmdW5jdGlvbiBub3RpZnlSZWRyYXcoXywgc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLm9uTmVlZHNSZWRyYXcgJiYgc3RhdGUub25OZWVkc1JlZHJhdygpO1xufTtcbnZhciB1cGREYXRhUGhvdG9ucyA9IGZ1bmN0aW9uIHVwZERhdGFQaG90b25zKF8sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUuaXNTaGFkb3cpIHtcbiAgICAvLyBBZGQgcGhvdG9uIHBhcnRpY2xlc1xuICAgIHZhciBsaW5rUGFydGljbGVzQWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlcyk7XG4gICAgc3RhdGUuZ3JhcGhEYXRhLmxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgIHZhciBudW1QaG90b25zID0gTWF0aC5yb3VuZChNYXRoLmFicyhsaW5rUGFydGljbGVzQWNjZXNzb3IobGluaykpKTtcbiAgICAgIGlmIChudW1QaG90b25zKSB7XG4gICAgICAgIGxpbmsuX19waG90b25zID0gX3RvQ29uc3VtYWJsZUFycmF5KEFycmF5KG51bVBob3RvbnMpKS5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgbGluay5fX3Bob3RvbnM7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG52YXIgQ2FudmFzRm9yY2VHcmFwaCA9IEthcHN1bGUoe1xuICBwcm9wczoge1xuICAgIGdyYXBoRGF0YToge1xuICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICBsaW5rczogW11cbiAgICAgIH0sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoXywgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUuZW5naW5lUnVubmluZyA9IGZhbHNlOyAvLyBQYXVzZSBzaW11bGF0aW9uXG4gICAgICAgIHVwZERhdGFQaG90b25zKF8sIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhZ01vZGU6IHtcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShkYWdNb2RlLCBzdGF0ZSkge1xuICAgICAgICAvLyB0ZCwgYnUsIGxyLCBybCwgcmFkaWFsaW4sIHJhZGlhbG91dFxuICAgICAgICAhZGFnTW9kZSAmJiAoc3RhdGUuZ3JhcGhEYXRhLm5vZGVzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuIG4uZnggPSBuLmZ5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9KTsgLy8gdW5maXggbm9kZXMgd2hlbiBkaXNhYmxpbmcgZGFnIG1vZGVcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhZ0xldmVsRGlzdGFuY2U6IHt9LFxuICAgIGRhZ05vZGVGaWx0ZXI6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdChub2RlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25EYWdFcnJvcjoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG5vZGVSZWxTaXplOiB7XG4gICAgICBcImRlZmF1bHRcIjogNCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgLy8gYXJlYSBwZXIgdmFsIHVuaXRcbiAgICBub2RlSWQ6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAnaWQnXG4gICAgfSxcbiAgICBub2RlVmFsOiB7XG4gICAgICBcImRlZmF1bHRcIjogJ3ZhbCcsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIG5vZGVDb2xvcjoge1xuICAgICAgXCJkZWZhdWx0XCI6ICdjb2xvcicsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIG5vZGVBdXRvQ29sb3JCeToge30sXG4gICAgbm9kZUNhbnZhc09iamVjdDoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBub2RlQ2FudmFzT2JqZWN0TW9kZToge1xuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gJ3JlcGxhY2UnO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbm9kZVZpc2liaWxpdHk6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBsaW5rU291cmNlOiB7XG4gICAgICBcImRlZmF1bHRcIjogJ3NvdXJjZSdcbiAgICB9LFxuICAgIGxpbmtUYXJnZXQ6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAndGFyZ2V0J1xuICAgIH0sXG4gICAgbGlua1Zpc2liaWxpdHk6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBsaW5rQ29sb3I6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAnY29sb3InLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBsaW5rQXV0b0NvbG9yQnk6IHt9LFxuICAgIGxpbmtMaW5lRGFzaDoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBsaW5rV2lkdGg6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBsaW5rQ3VydmF0dXJlOiB7XG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua0NhbnZhc09iamVjdDoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBsaW5rQ2FudmFzT2JqZWN0TW9kZToge1xuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gJ3JlcGxhY2UnO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua0RpcmVjdGlvbmFsQXJyb3dMZW5ndGg6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBsaW5rRGlyZWN0aW9uYWxBcnJvd0NvbG9yOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIGxpbmtEaXJlY3Rpb25hbEFycm93UmVsUG9zOiB7XG4gICAgICBcImRlZmF1bHRcIjogMC41LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICAvLyB2YWx1ZSBiZXR3ZWVuIDA8PjEgaW5kaWNhdGluZyB0aGUgcmVsYXRpdmUgcG9zIGFsb25nIHRoZSAoZXhwb3NlZCkgbGluZVxuICAgIGxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlczoge1xuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiB1cGREYXRhUGhvdG9uc1xuICAgIH0sXG4gICAgLy8gYW5pbWF0ZSBwaG90b25zIHRyYXZlbGxpbmcgaW4gdGhlIGxpbmsgZGlyZWN0aW9uXG4gICAgbGlua0RpcmVjdGlvbmFsUGFydGljbGVTcGVlZDoge1xuICAgICAgXCJkZWZhdWx0XCI6IDAuMDEsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgLy8gaW4gbGluayBsZW5ndGggcmF0aW8gcGVyIGZyYW1lXG4gICAgbGlua0RpcmVjdGlvbmFsUGFydGljbGVPZmZzZXQ6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIC8vIHN0YXJ0aW5nIHBvc2l0aW9uIG9mZnNldCBhbG9uZyB0aGUgbGluaydzIGxlbmd0aCwgbGlrZSBhIHByZS1kZWxheS4gVmFsdWVzIGJldHdlZW4gWzAsIDFdXG4gICAgbGlua0RpcmVjdGlvbmFsUGFydGljbGVXaWR0aDoge1xuICAgICAgXCJkZWZhdWx0XCI6IDQsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgbGlua0RpcmVjdGlvbmFsUGFydGljbGVDb2xvcjoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlQ2FudmFzT2JqZWN0OiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgZ2xvYmFsU2NhbGU6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGQzQWxwaGFNaW46IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGQzQWxwaGFEZWNheToge1xuICAgICAgXCJkZWZhdWx0XCI6IDAuMDIyOCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGFscGhhRGVjYXksIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmZvcmNlTGF5b3V0LmFscGhhRGVjYXkoYWxwaGFEZWNheSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkM0FscGhhVGFyZ2V0OiB7XG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGFscGhhVGFyZ2V0LCBzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5mb3JjZUxheW91dC5hbHBoYVRhcmdldChhbHBoYVRhcmdldCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkM1ZlbG9jaXR5RGVjYXk6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLjQsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSh2ZWxvY2l0eURlY2F5LCBzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5mb3JjZUxheW91dC52ZWxvY2l0eURlY2F5KHZlbG9jaXR5RGVjYXkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2FybXVwVGlja3M6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIC8vIGhvdyBtYW55IHRpbWVzIHRvIHRpY2sgdGhlIGZvcmNlIGVuZ2luZSBhdCBpbml0IGJlZm9yZSBzdGFydGluZyB0byByZW5kZXJcbiAgICBjb29sZG93blRpY2tzOiB7XG4gICAgICBcImRlZmF1bHRcIjogSW5maW5pdHksXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgY29vbGRvd25UaW1lOiB7XG4gICAgICBcImRlZmF1bHRcIjogMTUwMDAsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgLy8gbXNcbiAgICBvblVwZGF0ZToge1xuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge30sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25GaW5pc2hVcGRhdGU6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHt9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uRW5naW5lVGljazoge1xuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge30sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25FbmdpbmVTdG9wOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbk5lZWRzUmVkcmF3OiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgaXNTaGFkb3c6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgLy8gRXhwb3NlIGQzIGZvcmNlcyBmb3IgZXh0ZXJuYWwgbWFuaXB1bGF0aW9uXG4gICAgZDNGb3JjZTogZnVuY3Rpb24gZDNGb3JjZShzdGF0ZSwgZm9yY2VOYW1lLCBmb3JjZUZuKSB7XG4gICAgICBpZiAoZm9yY2VGbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5mb3JjZUxheW91dC5mb3JjZShmb3JjZU5hbWUpOyAvLyBGb3JjZSBnZXR0ZXJcbiAgICAgIH1cbiAgICAgIHN0YXRlLmZvcmNlTGF5b3V0LmZvcmNlKGZvcmNlTmFtZSwgZm9yY2VGbik7IC8vIEZvcmNlIHNldHRlclxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkM1JlaGVhdFNpbXVsYXRpb246IGZ1bmN0aW9uIGQzUmVoZWF0U2ltdWxhdGlvbihzdGF0ZSkge1xuICAgICAgc3RhdGUuZm9yY2VMYXlvdXQuYWxwaGEoMSk7XG4gICAgICB0aGlzLnJlc2V0Q291bnRkb3duKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIHJlc2V0IGNvb2xkb3duIHN0YXRlXG4gICAgcmVzZXRDb3VudGRvd246IGZ1bmN0aW9uIHJlc2V0Q291bnRkb3duKHN0YXRlKSB7XG4gICAgICBzdGF0ZS5jbnRUaWNrcyA9IDA7XG4gICAgICBzdGF0ZS5zdGFydFRpY2tUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgIHN0YXRlLmVuZ2luZVJ1bm5pbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBpc0VuZ2luZVJ1bm5pbmc6IGZ1bmN0aW9uIGlzRW5naW5lUnVubmluZyhzdGF0ZSkge1xuICAgICAgcmV0dXJuICEhc3RhdGUuZW5naW5lUnVubmluZztcbiAgICB9LFxuICAgIHRpY2tGcmFtZTogZnVuY3Rpb24gdGlja0ZyYW1lKHN0YXRlKSB7XG4gICAgICAhc3RhdGUuaXNTaGFkb3cgJiYgbGF5b3V0VGljaygpO1xuICAgICAgcGFpbnRMaW5rcygpO1xuICAgICAgIXN0YXRlLmlzU2hhZG93ICYmIHBhaW50QXJyb3dzKCk7XG4gICAgICAhc3RhdGUuaXNTaGFkb3cgJiYgcGFpbnRQaG90b25zKCk7XG4gICAgICBwYWludE5vZGVzKCk7XG4gICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy9cblxuICAgICAgZnVuY3Rpb24gbGF5b3V0VGljaygpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZ2luZVJ1bm5pbmcpIHtcbiAgICAgICAgICBpZiAoKytzdGF0ZS5jbnRUaWNrcyA+IHN0YXRlLmNvb2xkb3duVGlja3MgfHwgbmV3IERhdGUoKSAtIHN0YXRlLnN0YXJ0VGlja1RpbWUgPiBzdGF0ZS5jb29sZG93blRpbWUgfHwgc3RhdGUuZDNBbHBoYU1pbiA+IDAgJiYgc3RhdGUuZm9yY2VMYXlvdXQuYWxwaGEoKSA8IHN0YXRlLmQzQWxwaGFNaW4pIHtcbiAgICAgICAgICAgIHN0YXRlLmVuZ2luZVJ1bm5pbmcgPSBmYWxzZTsgLy8gU3RvcCB0aWNraW5nIGdyYXBoXG4gICAgICAgICAgICBzdGF0ZS5vbkVuZ2luZVN0b3AoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuZm9yY2VMYXlvdXQudGljaygpOyAvLyBUaWNrIGl0XG4gICAgICAgICAgICBzdGF0ZS5vbkVuZ2luZVRpY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhaW50Tm9kZXMoKSB7XG4gICAgICAgIHZhciBnZXRWaXNpYmlsaXR5ID0gYWNjZXNzb3JGbihzdGF0ZS5ub2RlVmlzaWJpbGl0eSk7XG4gICAgICAgIHZhciBnZXRWYWwgPSBhY2Nlc3NvckZuKHN0YXRlLm5vZGVWYWwpO1xuICAgICAgICB2YXIgZ2V0Q29sb3IgPSBhY2Nlc3NvckZuKHN0YXRlLm5vZGVDb2xvcik7XG4gICAgICAgIHZhciBnZXROb2RlQ2FudmFzT2JqZWN0TW9kZSA9IGFjY2Vzc29yRm4oc3RhdGUubm9kZUNhbnZhc09iamVjdE1vZGUpO1xuICAgICAgICB2YXIgY3R4ID0gc3RhdGUuY3R4O1xuXG4gICAgICAgIC8vIERyYXcgd2lkZXIgbm9kZXMgYnkgMXB4IG9uIHNoYWRvdyBjYW52YXMgZm9yIG1vcmUgcHJlY2lzZSBob3ZlcmluZyAoZHVlIHRvIGJvdW5kYXJ5IGFudGktYWxpYXNpbmcpXG4gICAgICAgIHZhciBwYWRBbW91bnQgPSBzdGF0ZS5pc1NoYWRvdyAvIHN0YXRlLmdsb2JhbFNjYWxlO1xuICAgICAgICB2YXIgdmlzaWJsZU5vZGVzID0gc3RhdGUuZ3JhcGhEYXRhLm5vZGVzLmZpbHRlcihnZXRWaXNpYmlsaXR5KTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdmlzaWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB2YXIgbm9kZUNhbnZhc09iamVjdE1vZGUgPSBnZXROb2RlQ2FudmFzT2JqZWN0TW9kZShub2RlKTtcbiAgICAgICAgICBpZiAoc3RhdGUubm9kZUNhbnZhc09iamVjdCAmJiAobm9kZUNhbnZhc09iamVjdE1vZGUgPT09ICdiZWZvcmUnIHx8IG5vZGVDYW52YXNPYmplY3RNb2RlID09PSAncmVwbGFjZScpKSB7XG4gICAgICAgICAgICAvLyBDdXN0b20gbm9kZSBiZWZvcmUvcmVwbGFjZSBwYWludFxuICAgICAgICAgICAgc3RhdGUubm9kZUNhbnZhc09iamVjdChub2RlLCBjdHgsIHN0YXRlLmdsb2JhbFNjYWxlKTtcbiAgICAgICAgICAgIGlmIChub2RlQ2FudmFzT2JqZWN0TW9kZSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEcmF3IHdpZGVyIG5vZGVzIGJ5IDFweCBvbiBzaGFkb3cgY2FudmFzIGZvciBtb3JlIHByZWNpc2UgaG92ZXJpbmcgKGR1ZSB0byBib3VuZGFyeSBhbnRpLWFsaWFzaW5nKVxuICAgICAgICAgIHZhciByID0gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIGdldFZhbChub2RlKSB8fCAxKSkgKiBzdGF0ZS5ub2RlUmVsU2l6ZSArIHBhZEFtb3VudDtcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4LmFyYyhub2RlLngsIG5vZGUueSwgciwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ2V0Q29sb3Iobm9kZSkgfHwgJ3JnYmEoMzEsIDEyMCwgMTgwLCAwLjkyKSc7XG4gICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICBpZiAoc3RhdGUubm9kZUNhbnZhc09iamVjdCAmJiBub2RlQ2FudmFzT2JqZWN0TW9kZSA9PT0gJ2FmdGVyJykge1xuICAgICAgICAgICAgLy8gQ3VzdG9tIG5vZGUgYWZ0ZXIgcGFpbnRcbiAgICAgICAgICAgIHN0YXRlLm5vZGVDYW52YXNPYmplY3Qobm9kZSwgc3RhdGUuY3R4LCBzdGF0ZS5nbG9iYWxTY2FsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhaW50TGlua3MoKSB7XG4gICAgICAgIHZhciBnZXRWaXNpYmlsaXR5ID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rVmlzaWJpbGl0eSk7XG4gICAgICAgIHZhciBnZXRDb2xvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0NvbG9yKTtcbiAgICAgICAgdmFyIGdldFdpZHRoID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rV2lkdGgpO1xuICAgICAgICB2YXIgZ2V0TGluZURhc2ggPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtMaW5lRGFzaCk7XG4gICAgICAgIHZhciBnZXRDdXJ2YXR1cmUgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtDdXJ2YXR1cmUpO1xuICAgICAgICB2YXIgZ2V0TGlua0NhbnZhc09iamVjdE1vZGUgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtDYW52YXNPYmplY3RNb2RlKTtcbiAgICAgICAgdmFyIGN0eCA9IHN0YXRlLmN0eDtcblxuICAgICAgICAvLyBEcmF3IHdpZGVyIGxpbmVzIGJ5IDJweCBvbiBzaGFkb3cgY2FudmFzIGZvciBtb3JlIHByZWNpc2UgaG92ZXJpbmcgKGR1ZSB0byBib3VuZGFyeSBhbnRpLWFsaWFzaW5nKVxuICAgICAgICB2YXIgcGFkQW1vdW50ID0gc3RhdGUuaXNTaGFkb3cgKiAyO1xuICAgICAgICB2YXIgdmlzaWJsZUxpbmtzID0gc3RhdGUuZ3JhcGhEYXRhLmxpbmtzLmZpbHRlcihnZXRWaXNpYmlsaXR5KTtcbiAgICAgICAgdmlzaWJsZUxpbmtzLmZvckVhY2goY2FsY0xpbmtDb250cm9sUG9pbnRzKTsgLy8gY2FsY3VsYXRlIGN1cnZhdHVyZSBjb250cm9sIHBvaW50cyBmb3IgYWxsIHZpc2libGUgbGlua3NcblxuICAgICAgICB2YXIgYmVmb3JlQ3VzdG9tTGlua3MgPSBbXSxcbiAgICAgICAgICBhZnRlckN1c3RvbUxpbmtzID0gW10sXG4gICAgICAgICAgZGVmYXVsdFBhaW50TGlua3MgPSB2aXNpYmxlTGlua3M7XG4gICAgICAgIGlmIChzdGF0ZS5saW5rQ2FudmFzT2JqZWN0KSB7XG4gICAgICAgICAgdmFyIHJlcGxhY2VDdXN0b21MaW5rcyA9IFtdLFxuICAgICAgICAgICAgb3RoZXJDdXN0b21MaW5rcyA9IFtdO1xuICAgICAgICAgIHZpc2libGVMaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgYmVmb3JlOiBiZWZvcmVDdXN0b21MaW5rcyxcbiAgICAgICAgICAgICAgYWZ0ZXI6IGFmdGVyQ3VzdG9tTGlua3MsXG4gICAgICAgICAgICAgIHJlcGxhY2U6IHJlcGxhY2VDdXN0b21MaW5rc1xuICAgICAgICAgICAgfVtnZXRMaW5rQ2FudmFzT2JqZWN0TW9kZShkKV0gfHwgb3RoZXJDdXN0b21MaW5rcykucHVzaChkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWZhdWx0UGFpbnRMaW5rcyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYmVmb3JlQ3VzdG9tTGlua3MpLCBhZnRlckN1c3RvbUxpbmtzLCBvdGhlckN1c3RvbUxpbmtzKTtcbiAgICAgICAgICBiZWZvcmVDdXN0b21MaW5rcyA9IGJlZm9yZUN1c3RvbUxpbmtzLmNvbmNhdChyZXBsYWNlQ3VzdG9tTGlua3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3VzdG9tIGxpbmsgYmVmb3JlIHBhaW50c1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBiZWZvcmVDdXN0b21MaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLmxpbmtDYW52YXNPYmplY3QobGluaywgY3R4LCBzdGF0ZS5nbG9iYWxTY2FsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgIC8vIEJ1bmRsZSBzdHJva2VzIHBlciB1bmlxdWUgY29sb3Ivd2lkdGgvZGFzaCBmb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uXG4gICAgICAgIHZhciBsaW5rc1BlckNvbG9yID0gaW5kZXhCeShkZWZhdWx0UGFpbnRMaW5rcywgW2dldENvbG9yLCBnZXRXaWR0aCwgZ2V0TGluZURhc2hdKTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMobGlua3NQZXJDb2xvcikuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgY29sb3IgPSBfcmVmMlswXSxcbiAgICAgICAgICAgIGxpbmtzUGVyV2lkdGggPSBfcmVmMlsxXTtcbiAgICAgICAgICB2YXIgbGluZUNvbG9yID0gIWNvbG9yIHx8IGNvbG9yID09PSAndW5kZWZpbmVkJyA/ICdyZ2JhKDAsMCwwLDAuMTUpJyA6IGNvbG9yO1xuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGxpbmtzUGVyV2lkdGgpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICAgICAgICAgIHdpZHRoID0gX3JlZjRbMF0sXG4gICAgICAgICAgICAgIGxpbmVzUGVyTGluZURhc2ggPSBfcmVmNFsxXTtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSAod2lkdGggfHwgMSkgLyBzdGF0ZS5nbG9iYWxTY2FsZSArIHBhZEFtb3VudDtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGxpbmVzUGVyTGluZURhc2gpLmZvckVhY2goZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICAgICAgICAgIHZhciBfcmVmNiA9IF9zbGljZWRUb0FycmF5KF9yZWY1LCAyKTtcbiAgICAgICAgICAgICAgICBfcmVmNlswXTtcbiAgICAgICAgICAgICAgICB2YXIgbGlua3MgPSBfcmVmNlsxXTtcbiAgICAgICAgICAgICAgdmFyIGxpbmVEYXNoU2VnbWVudHMgPSBnZXRMaW5lRGFzaChsaW5rc1swXSk7XG4gICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgbGlua3MuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGxpbmsuc291cmNlO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBsaW5rLnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0IHx8ICFlbmQgfHwgIXN0YXJ0Lmhhc093blByb3BlcnR5KCd4JykgfHwgIWVuZC5oYXNPd25Qcm9wZXJ0eSgneCcpKSByZXR1cm47IC8vIHNraXAgaW52YWxpZCBsaW5rXG5cbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHN0YXJ0LngsIHN0YXJ0LnkpO1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sUG9pbnRzID0gbGluay5fX2NvbnRyb2xQb2ludHM7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250cm9sUG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgICAvLyBTdHJhaWdodCBsaW5lXG4gICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGVuZC54LCBlbmQueSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIFVzZSBxdWFkcmF0aWMgY3VydmVzIGZvciByZWd1bGFyIGxpbmVzIGFuZCBiZXppZXIgZm9yIGxvb3BzXG4gICAgICAgICAgICAgICAgICBjdHhbY29udHJvbFBvaW50cy5sZW5ndGggPT09IDIgPyAncXVhZHJhdGljQ3VydmVUbycgOiAnYmV6aWVyQ3VydmVUbyddLmFwcGx5KGN0eCwgX3RvQ29uc3VtYWJsZUFycmF5KGNvbnRyb2xQb2ludHMpLmNvbmNhdChbZW5kLngsIGVuZC55XSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxpbmVDb2xvcjtcbiAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKGxpbmVEYXNoU2VnbWVudHMgfHwgW10pO1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgLy8gQ3VzdG9tIGxpbmsgYWZ0ZXIgcGFpbnRzXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGFmdGVyQ3VzdG9tTGlua3MuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5saW5rQ2FudmFzT2JqZWN0KGxpbmssIGN0eCwgc3RhdGUuZ2xvYmFsU2NhbGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICAvL1xuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGNMaW5rQ29udHJvbFBvaW50cyhsaW5rKSB7XG4gICAgICAgICAgdmFyIGN1cnZhdHVyZSA9IGdldEN1cnZhdHVyZShsaW5rKTtcbiAgICAgICAgICBpZiAoIWN1cnZhdHVyZSkge1xuICAgICAgICAgICAgLy8gc3RyYWlnaHQgbGluZVxuICAgICAgICAgICAgbGluay5fX2NvbnRyb2xQb2ludHMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3RhcnQgPSBsaW5rLnNvdXJjZTtcbiAgICAgICAgICB2YXIgZW5kID0gbGluay50YXJnZXQ7XG4gICAgICAgICAgaWYgKCFzdGFydCB8fCAhZW5kIHx8ICFzdGFydC5oYXNPd25Qcm9wZXJ0eSgneCcpIHx8ICFlbmQuaGFzT3duUHJvcGVydHkoJ3gnKSkgcmV0dXJuOyAvLyBza2lwIGludmFsaWQgbGlua1xuXG4gICAgICAgICAgdmFyIGwgPSBNYXRoLnNxcnQoTWF0aC5wb3coZW5kLnggLSBzdGFydC54LCAyKSArIE1hdGgucG93KGVuZC55IC0gc3RhcnQueSwgMikpOyAvLyBsaW5lIGxlbmd0aFxuXG4gICAgICAgICAgaWYgKGwgPiAwKSB7XG4gICAgICAgICAgICB2YXIgYSA9IE1hdGguYXRhbjIoZW5kLnkgLSBzdGFydC55LCBlbmQueCAtIHN0YXJ0LngpOyAvLyBsaW5lIGFuZ2xlXG4gICAgICAgICAgICB2YXIgZCA9IGwgKiBjdXJ2YXR1cmU7IC8vIGNvbnRyb2wgcG9pbnQgZGlzdGFuY2VcblxuICAgICAgICAgICAgdmFyIGNwID0ge1xuICAgICAgICAgICAgICAvLyBjb250cm9sIHBvaW50XG4gICAgICAgICAgICAgIHg6IChzdGFydC54ICsgZW5kLngpIC8gMiArIGQgKiBNYXRoLmNvcyhhIC0gTWF0aC5QSSAvIDIpLFxuICAgICAgICAgICAgICB5OiAoc3RhcnQueSArIGVuZC55KSAvIDIgKyBkICogTWF0aC5zaW4oYSAtIE1hdGguUEkgLyAyKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxpbmsuX19jb250cm9sUG9pbnRzID0gW2NwLngsIGNwLnldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTYW1lIHBvaW50LCBkcmF3IGEgbG9vcFxuICAgICAgICAgICAgdmFyIF9kID0gY3VydmF0dXJlICogNzA7XG4gICAgICAgICAgICBsaW5rLl9fY29udHJvbFBvaW50cyA9IFtlbmQueCwgZW5kLnkgLSBfZCwgZW5kLnggKyBfZCwgZW5kLnldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFpbnRBcnJvd3MoKSB7XG4gICAgICAgIHZhciBBUlJPV19XSF9SQVRJTyA9IDEuNjtcbiAgICAgICAgdmFyIEFSUk9XX1ZMRU5fUkFUSU8gPSAwLjI7XG4gICAgICAgIHZhciBnZXRMZW5ndGggPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtEaXJlY3Rpb25hbEFycm93TGVuZ3RoKTtcbiAgICAgICAgdmFyIGdldFJlbFBvcyA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsQXJyb3dSZWxQb3MpO1xuICAgICAgICB2YXIgZ2V0VmlzaWJpbGl0eSA9IGFjY2Vzc29yRm4oc3RhdGUubGlua1Zpc2liaWxpdHkpO1xuICAgICAgICB2YXIgZ2V0Q29sb3IgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtEaXJlY3Rpb25hbEFycm93Q29sb3IgfHwgc3RhdGUubGlua0NvbG9yKTtcbiAgICAgICAgdmFyIGdldE5vZGVWYWwgPSBhY2Nlc3NvckZuKHN0YXRlLm5vZGVWYWwpO1xuICAgICAgICB2YXIgY3R4ID0gc3RhdGUuY3R4O1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBzdGF0ZS5ncmFwaERhdGEubGlua3MuZmlsdGVyKGdldFZpc2liaWxpdHkpLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICB2YXIgYXJyb3dMZW5ndGggPSBnZXRMZW5ndGgobGluayk7XG4gICAgICAgICAgaWYgKCFhcnJvd0xlbmd0aCB8fCBhcnJvd0xlbmd0aCA8IDApIHJldHVybjtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBsaW5rLnNvdXJjZTtcbiAgICAgICAgICB2YXIgZW5kID0gbGluay50YXJnZXQ7XG4gICAgICAgICAgaWYgKCFzdGFydCB8fCAhZW5kIHx8ICFzdGFydC5oYXNPd25Qcm9wZXJ0eSgneCcpIHx8ICFlbmQuaGFzT3duUHJvcGVydHkoJ3gnKSkgcmV0dXJuOyAvLyBza2lwIGludmFsaWQgbGlua1xuXG4gICAgICAgICAgdmFyIHN0YXJ0UiA9IE1hdGguc3FydChNYXRoLm1heCgwLCBnZXROb2RlVmFsKHN0YXJ0KSB8fCAxKSkgKiBzdGF0ZS5ub2RlUmVsU2l6ZTtcbiAgICAgICAgICB2YXIgZW5kUiA9IE1hdGguc3FydChNYXRoLm1heCgwLCBnZXROb2RlVmFsKGVuZCkgfHwgMSkpICogc3RhdGUubm9kZVJlbFNpemU7XG4gICAgICAgICAgdmFyIGFycm93UmVsUG9zID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgZ2V0UmVsUG9zKGxpbmspKSk7XG4gICAgICAgICAgdmFyIGFycm93Q29sb3IgPSBnZXRDb2xvcihsaW5rKSB8fCAncmdiYSgwLDAsMCwwLjI4KSc7XG4gICAgICAgICAgdmFyIGFycm93SGFsZldpZHRoID0gYXJyb3dMZW5ndGggLyBBUlJPV19XSF9SQVRJTyAvIDI7XG5cbiAgICAgICAgICAvLyBDb25zdHJ1Y3QgYmV6aWVyIGZvciBjdXJ2ZWQgbGluZXNcbiAgICAgICAgICB2YXIgYnpMaW5lID0gbGluay5fX2NvbnRyb2xQb2ludHMgJiYgX2NvbnN0cnVjdChCZXppZXIsIFtzdGFydC54LCBzdGFydC55XS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxpbmsuX19jb250cm9sUG9pbnRzKSwgW2VuZC54LCBlbmQueV0pKTtcbiAgICAgICAgICB2YXIgZ2V0Q29vcmRzQWxvbmdMaW5lID0gYnpMaW5lID8gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBiekxpbmUuZ2V0KHQpO1xuICAgICAgICAgIH0gLy8gZ2V0IHBvc2l0aW9uIGFsb25nIGJlemllciBsaW5lXG4gICAgICAgICAgOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLy8gc3RyYWlnaHQgbGluZTogaW50ZXJwb2xhdGUgbGluZWFybHlcbiAgICAgICAgICAgICAgeDogc3RhcnQueCArIChlbmQueCAtIHN0YXJ0LngpICogdCB8fCAwLFxuICAgICAgICAgICAgICB5OiBzdGFydC55ICsgKGVuZC55IC0gc3RhcnQueSkgKiB0IHx8IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgbGluZUxlbiA9IGJ6TGluZSA/IGJ6TGluZS5sZW5ndGgoKSA6IE1hdGguc3FydChNYXRoLnBvdyhlbmQueCAtIHN0YXJ0LngsIDIpICsgTWF0aC5wb3coZW5kLnkgLSBzdGFydC55LCAyKSk7XG4gICAgICAgICAgdmFyIHBvc0Fsb25nTGluZSA9IHN0YXJ0UiArIGFycm93TGVuZ3RoICsgKGxpbmVMZW4gLSBzdGFydFIgLSBlbmRSIC0gYXJyb3dMZW5ndGgpICogYXJyb3dSZWxQb3M7XG4gICAgICAgICAgdmFyIGFycm93SGVhZCA9IGdldENvb3Jkc0Fsb25nTGluZShwb3NBbG9uZ0xpbmUgLyBsaW5lTGVuKTtcbiAgICAgICAgICB2YXIgYXJyb3dUYWlsID0gZ2V0Q29vcmRzQWxvbmdMaW5lKChwb3NBbG9uZ0xpbmUgLSBhcnJvd0xlbmd0aCkgLyBsaW5lTGVuKTtcbiAgICAgICAgICB2YXIgYXJyb3dUYWlsVmVydGV4ID0gZ2V0Q29vcmRzQWxvbmdMaW5lKChwb3NBbG9uZ0xpbmUgLSBhcnJvd0xlbmd0aCAqICgxIC0gQVJST1dfVkxFTl9SQVRJTykpIC8gbGluZUxlbik7XG4gICAgICAgICAgdmFyIGFycm93VGFpbEFuZ2xlID0gTWF0aC5hdGFuMihhcnJvd0hlYWQueSAtIGFycm93VGFpbC55LCBhcnJvd0hlYWQueCAtIGFycm93VGFpbC54KSAtIE1hdGguUEkgLyAyO1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKGFycm93SGVhZC54LCBhcnJvd0hlYWQueSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhhcnJvd1RhaWwueCArIGFycm93SGFsZldpZHRoICogTWF0aC5jb3MoYXJyb3dUYWlsQW5nbGUpLCBhcnJvd1RhaWwueSArIGFycm93SGFsZldpZHRoICogTWF0aC5zaW4oYXJyb3dUYWlsQW5nbGUpKTtcbiAgICAgICAgICBjdHgubGluZVRvKGFycm93VGFpbFZlcnRleC54LCBhcnJvd1RhaWxWZXJ0ZXgueSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhhcnJvd1RhaWwueCAtIGFycm93SGFsZldpZHRoICogTWF0aC5jb3MoYXJyb3dUYWlsQW5nbGUpLCBhcnJvd1RhaWwueSAtIGFycm93SGFsZldpZHRoICogTWF0aC5zaW4oYXJyb3dUYWlsQW5nbGUpKTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYXJyb3dDb2xvcjtcbiAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhaW50UGhvdG9ucygpIHtcbiAgICAgICAgdmFyIGdldE51bVBob3RvbnMgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlcyk7XG4gICAgICAgIHZhciBnZXRTcGVlZCA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsUGFydGljbGVTcGVlZCk7XG4gICAgICAgIHZhciBnZXRPZmZzZXQgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlT2Zmc2V0KTtcbiAgICAgICAgdmFyIGdldERpYW1ldGVyID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVdpZHRoKTtcbiAgICAgICAgdmFyIGdldFZpc2liaWxpdHkgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtWaXNpYmlsaXR5KTtcbiAgICAgICAgdmFyIGdldENvbG9yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZUNvbG9yIHx8IHN0YXRlLmxpbmtDb2xvcik7XG4gICAgICAgIHZhciBjdHggPSBzdGF0ZS5jdHg7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHN0YXRlLmdyYXBoRGF0YS5saW5rcy5maWx0ZXIoZ2V0VmlzaWJpbGl0eSkuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgIHZhciBudW1DeWNsZVBob3RvbnMgPSBnZXROdW1QaG90b25zKGxpbmspO1xuICAgICAgICAgIGlmICghbGluay5oYXNPd25Qcm9wZXJ0eSgnX19waG90b25zJykgfHwgIWxpbmsuX19waG90b25zLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAgIHZhciBzdGFydCA9IGxpbmsuc291cmNlO1xuICAgICAgICAgIHZhciBlbmQgPSBsaW5rLnRhcmdldDtcbiAgICAgICAgICBpZiAoIXN0YXJ0IHx8ICFlbmQgfHwgIXN0YXJ0Lmhhc093blByb3BlcnR5KCd4JykgfHwgIWVuZC5oYXNPd25Qcm9wZXJ0eSgneCcpKSByZXR1cm47IC8vIHNraXAgaW52YWxpZCBsaW5rXG5cbiAgICAgICAgICB2YXIgcGFydGljbGVTcGVlZCA9IGdldFNwZWVkKGxpbmspO1xuICAgICAgICAgIHZhciBwYXJ0aWNsZU9mZnNldCA9IE1hdGguYWJzKGdldE9mZnNldChsaW5rKSk7XG4gICAgICAgICAgdmFyIHBob3RvbnMgPSBsaW5rLl9fcGhvdG9ucyB8fCBbXTtcbiAgICAgICAgICB2YXIgcGhvdG9uUiA9IE1hdGgubWF4KDAsIGdldERpYW1ldGVyKGxpbmspIC8gMikgLyBNYXRoLnNxcnQoc3RhdGUuZ2xvYmFsU2NhbGUpO1xuICAgICAgICAgIHZhciBwaG90b25Db2xvciA9IGdldENvbG9yKGxpbmspIHx8ICdyZ2JhKDAsMCwwLDAuMjgpJztcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gcGhvdG9uQ29sb3I7XG5cbiAgICAgICAgICAvLyBDb25zdHJ1Y3QgYmV6aWVyIGZvciBjdXJ2ZWQgbGluZXNcbiAgICAgICAgICB2YXIgYnpMaW5lID0gbGluay5fX2NvbnRyb2xQb2ludHMgPyBfY29uc3RydWN0KEJlemllciwgW3N0YXJ0LngsIHN0YXJ0LnldLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobGluay5fX2NvbnRyb2xQb2ludHMpLCBbZW5kLngsIGVuZC55XSkpIDogbnVsbDtcbiAgICAgICAgICB2YXIgY3ljbGVQaG90b25JZHggPSAwO1xuICAgICAgICAgIHZhciBuZWVkc0NsZWFudXAgPSBmYWxzZTsgLy8gd2hldGhlciBzb21lIHBob3RvbnMgbmVlZCB0byBiZSByZW1vdmVkIGZyb20gbGlzdFxuICAgICAgICAgIHBob3RvbnMuZm9yRWFjaChmdW5jdGlvbiAocGhvdG9uKSB7XG4gICAgICAgICAgICB2YXIgc2luZ2xlSG9wID0gISFwaG90b24uX19zaW5nbGVIb3A7XG4gICAgICAgICAgICBpZiAoIXBob3Rvbi5oYXNPd25Qcm9wZXJ0eSgnX19wcm9ncmVzc1JhdGlvJykpIHtcbiAgICAgICAgICAgICAgcGhvdG9uLl9fcHJvZ3Jlc3NSYXRpbyA9IHNpbmdsZUhvcCA/IDAgOiAoY3ljbGVQaG90b25JZHggKyBwYXJ0aWNsZU9mZnNldCkgLyBudW1DeWNsZVBob3RvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAhc2luZ2xlSG9wICYmIGN5Y2xlUGhvdG9uSWR4Kys7IC8vIGluY3JlYXNlIHJlZ3VsYXIgcGhvdG9uIGluZGV4XG5cbiAgICAgICAgICAgIHBob3Rvbi5fX3Byb2dyZXNzUmF0aW8gKz0gcGFydGljbGVTcGVlZDtcbiAgICAgICAgICAgIGlmIChwaG90b24uX19wcm9ncmVzc1JhdGlvID49IDEpIHtcbiAgICAgICAgICAgICAgaWYgKCFzaW5nbGVIb3ApIHtcbiAgICAgICAgICAgICAgICBwaG90b24uX19wcm9ncmVzc1JhdGlvID0gcGhvdG9uLl9fcHJvZ3Jlc3NSYXRpbyAlIDE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmVlZHNDbGVhbnVwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwaG90b25Qb3NSYXRpbyA9IHBob3Rvbi5fX3Byb2dyZXNzUmF0aW87XG4gICAgICAgICAgICB2YXIgY29vcmRzID0gYnpMaW5lID8gYnpMaW5lLmdldChwaG90b25Qb3NSYXRpbykgLy8gZ2V0IHBvc2l0aW9uIGFsb25nIGJlemllciBsaW5lXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgLy8gc3RyYWlnaHQgbGluZTogaW50ZXJwb2xhdGUgbGluZWFybHlcbiAgICAgICAgICAgICAgeDogc3RhcnQueCArIChlbmQueCAtIHN0YXJ0LngpICogcGhvdG9uUG9zUmF0aW8gfHwgMCxcbiAgICAgICAgICAgICAgeTogc3RhcnQueSArIChlbmQueSAtIHN0YXJ0LnkpICogcGhvdG9uUG9zUmF0aW8gfHwgMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZUNhbnZhc09iamVjdCkge1xuICAgICAgICAgICAgICBzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZUNhbnZhc09iamVjdChjb29yZHMueCwgY29vcmRzLnksIGxpbmssIGN0eCwgc3RhdGUuZ2xvYmFsU2NhbGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICBjdHguYXJjKGNvb3Jkcy54LCBjb29yZHMueSwgcGhvdG9uUiwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAobmVlZHNDbGVhbnVwKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZXhwaXJlZCBzaW5nbGUgaG9wIHBob3RvbnNcbiAgICAgICAgICAgIGxpbmsuX19waG90b25zID0gbGluay5fX3Bob3RvbnMuZmlsdGVyKGZ1bmN0aW9uIChwaG90b24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuICFwaG90b24uX19zaW5nbGVIb3AgfHwgcGhvdG9uLl9fcHJvZ3Jlc3NSYXRpbyA8PSAxO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVtaXRQYXJ0aWNsZTogZnVuY3Rpb24gZW1pdFBhcnRpY2xlKHN0YXRlLCBsaW5rKSB7XG4gICAgICBpZiAobGluaykge1xuICAgICAgICAhbGluay5fX3Bob3RvbnMgJiYgKGxpbmsuX19waG90b25zID0gW10pO1xuICAgICAgICBsaW5rLl9fcGhvdG9ucy5wdXNoKHtcbiAgICAgICAgICBfX3NpbmdsZUhvcDogdHJ1ZVxuICAgICAgICB9KTsgLy8gYWRkIGEgc2luZ2xlIGhvcCBwYXJ0aWNsZVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LFxuICBzdGF0ZUluaXQ6IGZ1bmN0aW9uIHN0YXRlSW5pdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9yY2VMYXlvdXQ6IGZvcmNlU2ltdWxhdGlvbigpLmZvcmNlKCdsaW5rJywgZm9yY2VMaW5rKCkpLmZvcmNlKCdjaGFyZ2UnLCBmb3JjZU1hbnlCb2R5KCkpLmZvcmNlKCdjZW50ZXInLCBmb3JjZUNlbnRlcigpKS5mb3JjZSgnZGFnUmFkaWFsJywgbnVsbCkuc3RvcCgpLFxuICAgICAgZW5naW5lUnVubmluZzogZmFsc2VcbiAgICB9O1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KGNhbnZhc0N0eCwgc3RhdGUpIHtcbiAgICAvLyBNYWluIGNhbnZhcyBvYmplY3QgdG8gbWFuaXB1bGF0ZVxuICAgIHN0YXRlLmN0eCA9IGNhbnZhc0N0eDtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoc3RhdGUsIGNoYW5nZWRQcm9wcykge1xuICAgIHN0YXRlLmVuZ2luZVJ1bm5pbmcgPSBmYWxzZTsgLy8gUGF1c2Ugc2ltdWxhdGlvblxuICAgIHN0YXRlLm9uVXBkYXRlKCk7XG4gICAgaWYgKHN0YXRlLm5vZGVBdXRvQ29sb3JCeSAhPT0gbnVsbCkge1xuICAgICAgLy8gQXV0byBhZGQgY29sb3IgdG8gdW5jb2xvcmVkIG5vZGVzXG4gICAgICBhdXRvQ29sb3JPYmplY3RzKHN0YXRlLmdyYXBoRGF0YS5ub2RlcywgYWNjZXNzb3JGbihzdGF0ZS5ub2RlQXV0b0NvbG9yQnkpLCBzdGF0ZS5ub2RlQ29sb3IpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUubGlua0F1dG9Db2xvckJ5ICE9PSBudWxsKSB7XG4gICAgICAvLyBBdXRvIGFkZCBjb2xvciB0byB1bmNvbG9yZWQgbGlua3NcbiAgICAgIGF1dG9Db2xvck9iamVjdHMoc3RhdGUuZ3JhcGhEYXRhLmxpbmtzLCBhY2Nlc3NvckZuKHN0YXRlLmxpbmtBdXRvQ29sb3JCeSksIHN0YXRlLmxpbmtDb2xvcik7XG4gICAgfVxuXG4gICAgLy8gcGFyc2UgbGlua3NcbiAgICBzdGF0ZS5ncmFwaERhdGEubGlua3MuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgbGluay5zb3VyY2UgPSBsaW5rW3N0YXRlLmxpbmtTb3VyY2VdO1xuICAgICAgbGluay50YXJnZXQgPSBsaW5rW3N0YXRlLmxpbmtUYXJnZXRdO1xuICAgIH0pO1xuXG4gICAgLy8gRmVlZCBkYXRhIHRvIGZvcmNlLWRpcmVjdGVkIGxheW91dFxuICAgIHN0YXRlLmZvcmNlTGF5b3V0LnN0b3AoKS5hbHBoYSgxKSAvLyByZS1oZWF0IHRoZSBzaW11bGF0aW9uXG4gICAgLm5vZGVzKHN0YXRlLmdyYXBoRGF0YS5ub2Rlcyk7XG5cbiAgICAvLyBhZGQgbGlua3MgKGlmIGxpbmsgZm9yY2UgaXMgc3RpbGwgYWN0aXZlKVxuICAgIHZhciBsaW5rRm9yY2UgPSBzdGF0ZS5mb3JjZUxheW91dC5mb3JjZSgnbGluaycpO1xuICAgIGlmIChsaW5rRm9yY2UpIHtcbiAgICAgIGxpbmtGb3JjZS5pZChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZFtzdGF0ZS5ub2RlSWRdO1xuICAgICAgfSkubGlua3Moc3RhdGUuZ3JhcGhEYXRhLmxpbmtzKTtcbiAgICB9XG5cbiAgICAvLyBzZXR1cCBkYWcgZm9yY2UgY29uc3RyYWludHNcbiAgICB2YXIgbm9kZURlcHRocyA9IHN0YXRlLmRhZ01vZGUgJiYgZ2V0RGFnRGVwdGhzKHN0YXRlLmdyYXBoRGF0YSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlW3N0YXRlLm5vZGVJZF07XG4gICAgfSwge1xuICAgICAgbm9kZUZpbHRlcjogc3RhdGUuZGFnTm9kZUZpbHRlcixcbiAgICAgIG9uTG9vcEVycm9yOiBzdGF0ZS5vbkRhZ0Vycm9yIHx8IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIHZhciBtYXhEZXB0aCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShPYmplY3QudmFsdWVzKG5vZGVEZXB0aHMgfHwgW10pKSk7XG4gICAgdmFyIGRhZ0xldmVsRGlzdGFuY2UgPSBzdGF0ZS5kYWdMZXZlbERpc3RhbmNlIHx8IHN0YXRlLmdyYXBoRGF0YS5ub2Rlcy5sZW5ndGggLyAobWF4RGVwdGggfHwgMSkgKiBEQUdfTEVWRUxfTk9ERV9SQVRJTyAqIChbJ3JhZGlhbGluJywgJ3JhZGlhbG91dCddLmluZGV4T2Yoc3RhdGUuZGFnTW9kZSkgIT09IC0xID8gMC43IDogMSk7XG5cbiAgICAvLyBSZXNldCByZWxldmFudCBmeC9meSB3aGVuIHN3YXBwaW5nIGRhZyBtb2Rlc1xuICAgIGlmIChbJ2xyJywgJ3JsJywgJ3RkJywgJ2J1J10uaW5jbHVkZXMoY2hhbmdlZFByb3BzLmRhZ01vZGUpKSB7XG4gICAgICB2YXIgcmVzZXRQcm9wID0gWydscicsICdybCddLmluY2x1ZGVzKGNoYW5nZWRQcm9wcy5kYWdNb2RlKSA/ICdmeCcgOiAnZnknO1xuICAgICAgc3RhdGUuZ3JhcGhEYXRhLm5vZGVzLmZpbHRlcihzdGF0ZS5kYWdOb2RlRmlsdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBkZWxldGUgbm9kZVtyZXNldFByb3BdO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRml4IG5vZGVzIHRvIHgseSBmb3IgZGFnIG1vZGVcbiAgICBpZiAoWydscicsICdybCcsICd0ZCcsICdidSddLmluY2x1ZGVzKHN0YXRlLmRhZ01vZGUpKSB7XG4gICAgICB2YXIgaW52ZXJ0ID0gWydybCcsICdidSddLmluY2x1ZGVzKHN0YXRlLmRhZ01vZGUpO1xuICAgICAgdmFyIGZpeEZuID0gZnVuY3Rpb24gZml4Rm4obm9kZSkge1xuICAgICAgICByZXR1cm4gKG5vZGVEZXB0aHNbbm9kZVtzdGF0ZS5ub2RlSWRdXSAtIG1heERlcHRoIC8gMikgKiBkYWdMZXZlbERpc3RhbmNlICogKGludmVydCA/IC0xIDogMSk7XG4gICAgICB9O1xuICAgICAgdmFyIF9yZXNldFByb3AgPSBbJ2xyJywgJ3JsJ10uaW5jbHVkZXMoc3RhdGUuZGFnTW9kZSkgPyAnZngnIDogJ2Z5JztcbiAgICAgIHN0YXRlLmdyYXBoRGF0YS5ub2Rlcy5maWx0ZXIoc3RhdGUuZGFnTm9kZUZpbHRlcikuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZVtfcmVzZXRQcm9wXSA9IGZpeEZuKG5vZGUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVXNlIHJhZGlhbCBmb3JjZSBmb3IgcmFkaWFsIGRhZ3NcbiAgICBzdGF0ZS5mb3JjZUxheW91dC5mb3JjZSgnZGFnUmFkaWFsJywgWydyYWRpYWxpbicsICdyYWRpYWxvdXQnXS5pbmRleE9mKHN0YXRlLmRhZ01vZGUpICE9PSAtMSA/IGZvcmNlUmFkaWFsKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgbm9kZURlcHRoID0gbm9kZURlcHRoc1tub2RlW3N0YXRlLm5vZGVJZF1dIHx8IC0xO1xuICAgICAgcmV0dXJuIChzdGF0ZS5kYWdNb2RlID09PSAncmFkaWFsaW4nID8gbWF4RGVwdGggLSBub2RlRGVwdGggOiBub2RlRGVwdGgpICogZGFnTGV2ZWxEaXN0YW5jZTtcbiAgICB9KS5zdHJlbmd0aChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIHN0YXRlLmRhZ05vZGVGaWx0ZXIobm9kZSkgPyAxIDogMDtcbiAgICB9KSA6IG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUud2FybXVwVGlja3MgJiYgIShzdGF0ZS5kM0FscGhhTWluID4gMCAmJiBzdGF0ZS5mb3JjZUxheW91dC5hbHBoYSgpIDwgc3RhdGUuZDNBbHBoYU1pbik7IGkrKykge1xuICAgICAgc3RhdGUuZm9yY2VMYXlvdXQudGljaygpO1xuICAgIH0gLy8gSW5pdGlhbCB0aWNrcyBiZWZvcmUgc3RhcnRpbmcgdG8gcmVuZGVyXG5cbiAgICB0aGlzLnJlc2V0Q291bnRkb3duKCk7XG4gICAgc3RhdGUub25GaW5pc2hVcGRhdGUoKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGxpbmtLYXBzdWxlIChrYXBzdWxlUHJvcE5hbWVzLCBrYXBzdWxlVHlwZSkge1xuICB2YXIgcHJvcE5hbWVzID0ga2Fwc3VsZVByb3BOYW1lcyBpbnN0YW5jZW9mIEFycmF5ID8ga2Fwc3VsZVByb3BOYW1lcyA6IFtrYXBzdWxlUHJvcE5hbWVzXTtcbiAgdmFyIGR1bW15SyA9IG5ldyBrYXBzdWxlVHlwZSgpOyAvLyBUbyBleHRyYWN0IGRlZmF1bHRzXG4gIGR1bW15Sy5fZGVzdHJ1Y3RvciAmJiBkdW1teUsuX2Rlc3RydWN0b3IoKTtcbiAgcmV0dXJuIHtcbiAgICBsaW5rUHJvcDogZnVuY3Rpb24gbGlua1Byb3AocHJvcCkge1xuICAgICAgLy8gbGluayBwcm9wZXJ0eSBjb25maWdcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFwiZGVmYXVsdFwiOiBkdW1teUtbcHJvcF0oKSxcbiAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKHYsIHN0YXRlKSB7XG4gICAgICAgICAgcHJvcE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVbcHJvcE5hbWVdW3Byb3BdKHYpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9LFxuICAgIGxpbmtNZXRob2Q6IGZ1bmN0aW9uIGxpbmtNZXRob2QobWV0aG9kKSB7XG4gICAgICAvLyBsaW5rIG1ldGhvZCBwYXNzLXRocm91Z2hcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXR1cm5WYWxzID0gW107XG4gICAgICAgIHByb3BOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgIHZhciBrYXBzdWxlSW5zdGFuY2UgPSBzdGF0ZVtwcm9wTmFtZV07XG4gICAgICAgICAgdmFyIHJldHVyblZhbCA9IGthcHN1bGVJbnN0YW5jZVttZXRob2RdLmFwcGx5KGthcHN1bGVJbnN0YW5jZSwgYXJncyk7XG4gICAgICAgICAgaWYgKHJldHVyblZhbCAhPT0ga2Fwc3VsZUluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm5WYWxzLnB1c2gocmV0dXJuVmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0dXJuVmFscy5sZW5ndGggPyByZXR1cm5WYWxzWzBdIDogdGhpczsgLy8gY2hhaW4gYmFzZWQgb24gdGhlIHBhcmVudCBvYmplY3QsIG5vdCB0aGUgaW5uZXIga2Fwc3VsZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBIT1ZFUl9DQU5WQVNfVEhST1RUTEVfREVMQVkgPSA4MDA7IC8vIG1zIHRvIHRocm90dGxlIHNoYWRvdyBjYW52YXMgdXBkYXRlcyBmb3IgcGVyZiBpbXByb3ZlbWVudFxudmFyIFpPT00yTk9ERVNfRkFDVE9SID0gNDtcbnZhciBEUkFHX0NMSUNLX1RPTEVSQU5DRV9QWCA9IDU7IC8vIEhvdyBtYW55IHB4IGNhbiBhIG5vZGUgYmUgYWNjaWRlbnRhbGx5IGRyYWdnZWQgYmVmb3JlIGRpc2FibGluZyB0aGUgY2xpY2tcblxuLy8gRXhwb3NlIGNvbmZpZyBmcm9tIGZvcmNlR3JhcGhcbnZhciBiaW5kRkcgPSBsaW5rS2Fwc3VsZSgnZm9yY2VHcmFwaCcsIENhbnZhc0ZvcmNlR3JhcGgpO1xudmFyIGJpbmRCb3RoID0gbGlua0thcHN1bGUoWydmb3JjZUdyYXBoJywgJ3NoYWRvd0dyYXBoJ10sIENhbnZhc0ZvcmNlR3JhcGgpO1xudmFyIGxpbmtlZFByb3BzID0gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIF90b0NvbnN1bWFibGVBcnJheShbJ25vZGVDb2xvcicsICdub2RlQXV0b0NvbG9yQnknLCAnbm9kZUNhbnZhc09iamVjdCcsICdub2RlQ2FudmFzT2JqZWN0TW9kZScsICdsaW5rQ29sb3InLCAnbGlua0F1dG9Db2xvckJ5JywgJ2xpbmtMaW5lRGFzaCcsICdsaW5rV2lkdGgnLCAnbGlua0NhbnZhc09iamVjdCcsICdsaW5rQ2FudmFzT2JqZWN0TW9kZScsICdsaW5rRGlyZWN0aW9uYWxBcnJvd0xlbmd0aCcsICdsaW5rRGlyZWN0aW9uYWxBcnJvd0NvbG9yJywgJ2xpbmtEaXJlY3Rpb25hbEFycm93UmVsUG9zJywgJ2xpbmtEaXJlY3Rpb25hbFBhcnRpY2xlcycsICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVNwZWVkJywgJ2xpbmtEaXJlY3Rpb25hbFBhcnRpY2xlT2Zmc2V0JywgJ2xpbmtEaXJlY3Rpb25hbFBhcnRpY2xlV2lkdGgnLCAnbGlua0RpcmVjdGlvbmFsUGFydGljbGVDb2xvcicsICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZUNhbnZhc09iamVjdCcsICdkYWdNb2RlJywgJ2RhZ0xldmVsRGlzdGFuY2UnLCAnZGFnTm9kZUZpbHRlcicsICdvbkRhZ0Vycm9yJywgJ2QzQWxwaGFNaW4nLCAnZDNBbHBoYURlY2F5JywgJ2QzVmVsb2NpdHlEZWNheScsICd3YXJtdXBUaWNrcycsICdjb29sZG93blRpY2tzJywgJ2Nvb2xkb3duVGltZScsICdvbkVuZ2luZVRpY2snLCAnb25FbmdpbmVTdG9wJ10ubWFwKGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBfZGVmaW5lUHJvcGVydHkoe30sIHAsIGJpbmRGRy5saW5rUHJvcChwKSk7XG59KSkuY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShbJ25vZGVSZWxTaXplJywgJ25vZGVJZCcsICdub2RlVmFsJywgJ25vZGVWaXNpYmlsaXR5JywgJ2xpbmtTb3VyY2UnLCAnbGlua1RhcmdldCcsICdsaW5rVmlzaWJpbGl0eScsICdsaW5rQ3VydmF0dXJlJ10ubWFwKGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBfZGVmaW5lUHJvcGVydHkoe30sIHAsIGJpbmRCb3RoLmxpbmtQcm9wKHApKTtcbn0pKSkpO1xudmFyIGxpbmtlZE1ldGhvZHMgPSBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgX3RvQ29uc3VtYWJsZUFycmF5KFsnZDNGb3JjZScsICdkM1JlaGVhdFNpbXVsYXRpb24nLCAnZW1pdFBhcnRpY2xlJ10ubWFwKGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBfZGVmaW5lUHJvcGVydHkoe30sIHAsIGJpbmRGRy5saW5rTWV0aG9kKHApKTtcbn0pKSk7XG5mdW5jdGlvbiBhZGp1c3RDYW52YXNTaXplKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5jYW52YXMpIHtcbiAgICB2YXIgY3VyV2lkdGggPSBzdGF0ZS5jYW52YXMud2lkdGg7XG4gICAgdmFyIGN1ckhlaWdodCA9IHN0YXRlLmNhbnZhcy5oZWlnaHQ7XG4gICAgaWYgKGN1cldpZHRoID09PSAzMDAgJiYgY3VySGVpZ2h0ID09PSAxNTApIHtcbiAgICAgIC8vIERlZmF1bHQgY2FudmFzIGRpbWVuc2lvbnNcbiAgICAgIGN1cldpZHRoID0gY3VySGVpZ2h0ID0gMDtcbiAgICB9XG4gICAgdmFyIHB4U2NhbGUgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbzsgLy8gMiBvbiByZXRpbmEgZGlzcGxheXNcbiAgICBjdXJXaWR0aCAvPSBweFNjYWxlO1xuICAgIGN1ckhlaWdodCAvPSBweFNjYWxlO1xuXG4gICAgLy8gUmVzaXplIGNhbnZhc2VzXG4gICAgW3N0YXRlLmNhbnZhcywgc3RhdGUuc2hhZG93Q2FudmFzXS5mb3JFYWNoKGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICAgIC8vIEVsZW1lbnQgc2l6ZVxuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQoc3RhdGUud2lkdGgsIFwicHhcIik7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQoc3RhdGUuaGVpZ2h0LCBcInB4XCIpO1xuXG4gICAgICAvLyBNZW1vcnkgc2l6ZSAoc2NhbGVkIHRvIGF2b2lkIGJsdXJyaW5lc3MpXG4gICAgICBjYW52YXMud2lkdGggPSBzdGF0ZS53aWR0aCAqIHB4U2NhbGU7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gc3RhdGUuaGVpZ2h0ICogcHhTY2FsZTtcblxuICAgICAgLy8gTm9ybWFsaXplIGNvb3JkaW5hdGUgc3lzdGVtIHRvIHVzZSBjc3MgcGl4ZWxzIChvbiBpbml0IG9ubHkpXG4gICAgICBpZiAoIWN1cldpZHRoICYmICFjdXJIZWlnaHQpIHtcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykuc2NhbGUocHhTY2FsZSwgcHhTY2FsZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZWxhdGl2ZSBjZW50ZXIgcGFubmluZyBiYXNlZCBvbiAwLDBcbiAgICB2YXIgayA9IHpvb21UcmFuc2Zvcm0oc3RhdGUuY2FudmFzKS5rO1xuICAgIHN0YXRlLnpvb20udHJhbnNsYXRlQnkoc3RhdGUuem9vbS5fX2Jhc2VFbGVtLCAoc3RhdGUud2lkdGggLSBjdXJXaWR0aCkgLyAyIC8gaywgKHN0YXRlLmhlaWdodCAtIGN1ckhlaWdodCkgLyAyIC8gayk7XG4gICAgc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiByZXNldFRyYW5zZm9ybShjdHgpIHtcbiAgdmFyIHB4UmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgY3R4LnNldFRyYW5zZm9ybShweFJhdGlvLCAwLCAwLCBweFJhdGlvLCAwLCAwKTtcbn1cbmZ1bmN0aW9uIGNsZWFyQ2FudmFzKGN0eCwgd2lkdGgsIGhlaWdodCkge1xuICBjdHguc2F2ZSgpO1xuICByZXNldFRyYW5zZm9ybShjdHgpOyAvLyByZXNldCB0cmFuc2Zvcm1cbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgY3R4LnJlc3RvcmUoKTsgLy9yZXN0b3JlIHRyYW5zZm9ybXNcbn1cblxuLy9cblxudmFyIGZvcmNlR3JhcGggPSBLYXBzdWxlKHtcbiAgcHJvcHM6IF9vYmplY3RTcHJlYWQyKHtcbiAgICB3aWR0aDoge1xuICAgICAgXCJkZWZhdWx0XCI6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKF8sIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBhZGp1c3RDYW52YXNTaXplKHN0YXRlKTtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgaGVpZ2h0OiB7XG4gICAgICBcImRlZmF1bHRcIjogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKF8sIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBhZGp1c3RDYW52YXNTaXplKHN0YXRlKTtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgZ3JhcGhEYXRhOiB7XG4gICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICBub2RlczogW10sXG4gICAgICAgIGxpbmtzOiBbXVxuICAgICAgfSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShkLCBzdGF0ZSkge1xuICAgICAgICAvLyBXaXBlIGNvbG9yIHJlZ2lzdHJ5IGlmIGFsbCBvYmplY3RzIGFyZSBuZXdcbiAgICAgICAgW2Qubm9kZXMsIGQubGlua3NdLmV2ZXJ5KGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgICByZXR1cm4gKGFyciB8fCBbXSkuZXZlcnkoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAhZC5oYXNPd25Qcm9wZXJ0eSgnX19pbmRleENvbG9yJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pICYmIHN0YXRlLmNvbG9yVHJhY2tlci5yZXNldCgpO1xuICAgICAgICBbe1xuICAgICAgICAgIHR5cGU6ICdOb2RlJyxcbiAgICAgICAgICBvYmpzOiBkLm5vZGVzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiAnTGluaycsXG4gICAgICAgICAgb2JqczogZC5saW5rc1xuICAgICAgICB9XS5mb3JFYWNoKGhleEluZGV4KTtcbiAgICAgICAgc3RhdGUuZm9yY2VHcmFwaC5ncmFwaERhdGEoZCk7XG4gICAgICAgIHN0YXRlLnNoYWRvd0dyYXBoLmdyYXBoRGF0YShkKTtcbiAgICAgICAgZnVuY3Rpb24gaGV4SW5kZXgoX3JlZjQpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IF9yZWY0LnR5cGUsXG4gICAgICAgICAgICBvYmpzID0gX3JlZjQub2JqcztcbiAgICAgICAgICBvYmpzLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgaWYgKCFkLmhhc093blByb3BlcnR5KCdfX2luZGV4Q29sb3InKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB2YXIgY3VyID0gc3RhdGUuY29sb3JUcmFja2VyLmxvb2t1cChkLl9faW5kZXhDb2xvcik7XG4gICAgICAgICAgICByZXR1cm4gIWN1ciB8fCAhY3VyLmhhc093blByb3BlcnR5KCdkJykgfHwgY3VyLmQgIT09IGQ7XG4gICAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgLy8gc3RvcmUgb2JqZWN0IGxvb2t1cCBjb2xvclxuICAgICAgICAgICAgZC5fX2luZGV4Q29sb3IgPSBzdGF0ZS5jb2xvclRyYWNrZXIucmVnaXN0ZXIoe1xuICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICBkOiBkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShjb2xvciwgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUuY2FudmFzICYmIGNvbG9yICYmIChzdGF0ZS5jYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9IGNvbG9yKTtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgbm9kZUxhYmVsOiB7XG4gICAgICBcImRlZmF1bHRcIjogJ25hbWUnLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG5vZGVQb2ludGVyQXJlYVBhaW50OiB7XG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UocGFpbnRGbiwgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUuc2hhZG93R3JhcGgubm9kZUNhbnZhc09iamVjdCghcGFpbnRGbiA/IG51bGwgOiBmdW5jdGlvbiAobm9kZSwgY3R4LCBnbG9iYWxTY2FsZSkge1xuICAgICAgICAgIHJldHVybiBwYWludEZuKG5vZGUsIG5vZGUuX19pbmRleENvbG9yLCBjdHgsIGdsb2JhbFNjYWxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRlLmZsdXNoU2hhZG93Q2FudmFzICYmIHN0YXRlLmZsdXNoU2hhZG93Q2FudmFzKCk7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGxpbmtQb2ludGVyQXJlYVBhaW50OiB7XG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UocGFpbnRGbiwgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUuc2hhZG93R3JhcGgubGlua0NhbnZhc09iamVjdCghcGFpbnRGbiA/IG51bGwgOiBmdW5jdGlvbiAobGluaywgY3R4LCBnbG9iYWxTY2FsZSkge1xuICAgICAgICAgIHJldHVybiBwYWludEZuKGxpbmssIGxpbmsuX19pbmRleENvbG9yLCBjdHgsIGdsb2JhbFNjYWxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRlLmZsdXNoU2hhZG93Q2FudmFzICYmIHN0YXRlLmZsdXNoU2hhZG93Q2FudmFzKCk7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGxpbmtMYWJlbDoge1xuICAgICAgXCJkZWZhdWx0XCI6ICduYW1lJyxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBsaW5rSG92ZXJQcmVjaXNpb246IHtcbiAgICAgIFwiZGVmYXVsdFwiOiA0LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG1pblpvb206IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLjAxLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKG1pblpvb20sIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLnpvb20uc2NhbGVFeHRlbnQoW21pblpvb20sIHN0YXRlLnpvb20uc2NhbGVFeHRlbnQoKVsxXV0pO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBtYXhab29tOiB7XG4gICAgICBcImRlZmF1bHRcIjogMTAwMCxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShtYXhab29tLCBzdGF0ZSkge1xuICAgICAgICBzdGF0ZS56b29tLnNjYWxlRXh0ZW50KFtzdGF0ZS56b29tLnNjYWxlRXh0ZW50KClbMF0sIG1heFpvb21dKTtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgZW5hYmxlTm9kZURyYWc6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGVuYWJsZVpvb21JbnRlcmFjdGlvbjoge1xuICAgICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgZW5hYmxlUGFuSW50ZXJhY3Rpb246IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGVuYWJsZVpvb21QYW5JbnRlcmFjdGlvbjoge1xuICAgICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgLy8gdG8gYmUgZGVwcmVjYXRlZFxuICAgIGVuYWJsZVBvaW50ZXJJbnRlcmFjdGlvbjoge1xuICAgICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoXywgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUuaG92ZXJPYmogPSBudWxsO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBhdXRvUGF1c2VSZWRyYXc6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTm9kZURyYWc6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHt9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTm9kZURyYWdFbmQ6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHt9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTm9kZUNsaWNrOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25Ob2RlUmlnaHRDbGljazoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTm9kZUhvdmVyOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25MaW5rQ2xpY2s6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbkxpbmtSaWdodENsaWNrOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25MaW5rSG92ZXI6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbkJhY2tncm91bmRDbGljazoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uQmFja2dyb3VuZFJpZ2h0Q2xpY2s6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBzaG93UG9pbnRlckN1cnNvcjoge1xuICAgICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25ab29tOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25ab29tRW5kOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25SZW5kZXJGcmFtZVByZToge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uUmVuZGVyRnJhbWVQb3N0OiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH1cbiAgfSwgbGlua2VkUHJvcHMpLFxuICBhbGlhc2VzOiB7XG4gICAgLy8gUHJvcCBuYW1lcyBzdXBwb3J0ZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgc3RvcEFuaW1hdGlvbjogJ3BhdXNlQW5pbWF0aW9uJ1xuICB9LFxuICBtZXRob2RzOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgZ3JhcGgyU2NyZWVuQ29vcmRzOiBmdW5jdGlvbiBncmFwaDJTY3JlZW5Db29yZHMoc3RhdGUsIHgsIHkpIHtcbiAgICAgIHZhciB0ID0gem9vbVRyYW5zZm9ybShzdGF0ZS5jYW52YXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAqIHQuayArIHQueCxcbiAgICAgICAgeTogeSAqIHQuayArIHQueVxuICAgICAgfTtcbiAgICB9LFxuICAgIHNjcmVlbjJHcmFwaENvb3JkczogZnVuY3Rpb24gc2NyZWVuMkdyYXBoQ29vcmRzKHN0YXRlLCB4LCB5KSB7XG4gICAgICB2YXIgdCA9IHpvb21UcmFuc2Zvcm0oc3RhdGUuY2FudmFzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6ICh4IC0gdC54KSAvIHQuayxcbiAgICAgICAgeTogKHkgLSB0LnkpIC8gdC5rXG4gICAgICB9O1xuICAgIH0sXG4gICAgY2VudGVyQXQ6IGZ1bmN0aW9uIGNlbnRlckF0KHN0YXRlLCB4LCB5LCB0cmFuc2l0aW9uRHVyYXRpb24pIHtcbiAgICAgIGlmICghc3RhdGUuY2FudmFzKSByZXR1cm4gbnVsbDsgLy8gbm8gY2FudmFzIHlldFxuXG4gICAgICAvLyBzZXR0ZXJcbiAgICAgIGlmICh4ICE9PSB1bmRlZmluZWQgfHwgeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmaW5hbFBvcyA9IE9iamVjdC5hc3NpZ24oe30sIHggIT09IHVuZGVmaW5lZCA/IHtcbiAgICAgICAgICB4OiB4XG4gICAgICAgIH0gOiB7fSwgeSAhPT0gdW5kZWZpbmVkID8ge1xuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSA6IHt9KTtcbiAgICAgICAgaWYgKCF0cmFuc2l0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgICAvLyBubyBhbmltYXRpb25cbiAgICAgICAgICBzZXRDZW50ZXIoZmluYWxQb3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnR3ZWVuR3JvdXAuYWRkKG5ldyBUd2VlbihnZXRDZW50ZXIoKSkudG8oZmluYWxQb3MsIHRyYW5zaXRpb25EdXJhdGlvbikuZWFzaW5nKEVhc2luZy5RdWFkcmF0aWMuT3V0KS5vblVwZGF0ZShzZXRDZW50ZXIpLnN0YXJ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXR0ZXJcbiAgICAgIHJldHVybiBnZXRDZW50ZXIoKTtcblxuICAgICAgLy9cblxuICAgICAgZnVuY3Rpb24gZ2V0Q2VudGVyKCkge1xuICAgICAgICB2YXIgdCA9IHpvb21UcmFuc2Zvcm0oc3RhdGUuY2FudmFzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiAoc3RhdGUud2lkdGggLyAyIC0gdC54KSAvIHQuayxcbiAgICAgICAgICB5OiAoc3RhdGUuaGVpZ2h0IC8gMiAtIHQueSkgLyB0LmtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHNldENlbnRlcihfcmVmNSkge1xuICAgICAgICB2YXIgeCA9IF9yZWY1LngsXG4gICAgICAgICAgeSA9IF9yZWY1Lnk7XG4gICAgICAgIHN0YXRlLnpvb20udHJhbnNsYXRlVG8oc3RhdGUuem9vbS5fX2Jhc2VFbGVtLCB4ID09PSB1bmRlZmluZWQgPyBnZXRDZW50ZXIoKS54IDogeCwgeSA9PT0gdW5kZWZpbmVkID8gZ2V0Q2VudGVyKCkueSA6IHkpO1xuICAgICAgICBzdGF0ZS5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICB6b29tOiBmdW5jdGlvbiB6b29tKHN0YXRlLCBrLCB0cmFuc2l0aW9uRHVyYXRpb24pIHtcbiAgICAgIGlmICghc3RhdGUuY2FudmFzKSByZXR1cm4gbnVsbDsgLy8gbm8gY2FudmFzIHlldFxuXG4gICAgICAvLyBzZXR0ZXJcbiAgICAgIGlmIChrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCF0cmFuc2l0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgICAvLyBubyBhbmltYXRpb25cbiAgICAgICAgICBzZXRab29tKGspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnR3ZWVuR3JvdXAuYWRkKG5ldyBUd2Vlbih7XG4gICAgICAgICAgICBrOiBnZXRab29tKClcbiAgICAgICAgICB9KS50byh7XG4gICAgICAgICAgICBrOiBrXG4gICAgICAgICAgfSwgdHJhbnNpdGlvbkR1cmF0aW9uKS5lYXNpbmcoRWFzaW5nLlF1YWRyYXRpYy5PdXQpLm9uVXBkYXRlKGZ1bmN0aW9uIChfcmVmNikge1xuICAgICAgICAgICAgdmFyIGsgPSBfcmVmNi5rO1xuICAgICAgICAgICAgcmV0dXJuIHNldFpvb20oayk7XG4gICAgICAgICAgfSkuc3RhcnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGdldHRlclxuICAgICAgcmV0dXJuIGdldFpvb20oKTtcblxuICAgICAgLy9cblxuICAgICAgZnVuY3Rpb24gZ2V0Wm9vbSgpIHtcbiAgICAgICAgcmV0dXJuIHpvb21UcmFuc2Zvcm0oc3RhdGUuY2FudmFzKS5rO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc2V0Wm9vbShrKSB7XG4gICAgICAgIHN0YXRlLnpvb20uc2NhbGVUbyhzdGF0ZS56b29tLl9fYmFzZUVsZW0sIGspO1xuICAgICAgICBzdGF0ZS5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICB6b29tVG9GaXQ6IGZ1bmN0aW9uIHpvb21Ub0ZpdChzdGF0ZSkge1xuICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIHZhciBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxMDtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBiYm94QXJncyA9IG5ldyBBcnJheShfbGVuID4gMyA/IF9sZW4gLSAzIDogMCksIF9rZXkgPSAzOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGJib3hBcmdzW19rZXkgLSAzXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIHZhciBiYm94ID0gdGhpcy5nZXRHcmFwaEJib3guYXBwbHkodGhpcywgYmJveEFyZ3MpO1xuICAgICAgaWYgKGJib3gpIHtcbiAgICAgICAgdmFyIGNlbnRlciA9IHtcbiAgICAgICAgICB4OiAoYmJveC54WzBdICsgYmJveC54WzFdKSAvIDIsXG4gICAgICAgICAgeTogKGJib3gueVswXSArIGJib3gueVsxXSkgLyAyXG4gICAgICAgIH07XG4gICAgICAgIHZhciB6b29tSyA9IE1hdGgubWF4KDFlLTEyLCBNYXRoLm1pbigxZTEyLCAoc3RhdGUud2lkdGggLSBwYWRkaW5nICogMikgLyAoYmJveC54WzFdIC0gYmJveC54WzBdKSwgKHN0YXRlLmhlaWdodCAtIHBhZGRpbmcgKiAyKSAvIChiYm94LnlbMV0gLSBiYm94LnlbMF0pKSk7XG4gICAgICAgIHRoaXMuY2VudGVyQXQoY2VudGVyLngsIGNlbnRlci55LCB0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgICB0aGlzLnpvb20oem9vbUssIHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldEdyYXBoQmJveDogZnVuY3Rpb24gZ2V0R3JhcGhCYm94KHN0YXRlKSB7XG4gICAgICB2YXIgbm9kZUZpbHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICB2YXIgZ2V0VmFsID0gYWNjZXNzb3JGbihzdGF0ZS5ub2RlVmFsKTtcbiAgICAgIHZhciBnZXRSID0gZnVuY3Rpb24gZ2V0Uihub2RlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgZ2V0VmFsKG5vZGUpIHx8IDEpKSAqIHN0YXRlLm5vZGVSZWxTaXplO1xuICAgICAgfTtcbiAgICAgIHZhciBub2Rlc1BvcyA9IHN0YXRlLmdyYXBoRGF0YS5ub2Rlcy5maWx0ZXIobm9kZUZpbHRlcikubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogbm9kZS54LFxuICAgICAgICAgIHk6IG5vZGUueSxcbiAgICAgICAgICByOiBnZXRSKG5vZGUpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhbm9kZXNQb3MubGVuZ3RoID8gbnVsbCA6IHtcbiAgICAgICAgeDogW21pbihub2Rlc1BvcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS54IC0gbm9kZS5yO1xuICAgICAgICB9KSwgbWF4KG5vZGVzUG9zLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBub2RlLnggKyBub2RlLnI7XG4gICAgICAgIH0pXSxcbiAgICAgICAgeTogW21pbihub2Rlc1BvcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS55IC0gbm9kZS5yO1xuICAgICAgICB9KSwgbWF4KG5vZGVzUG9zLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBub2RlLnkgKyBub2RlLnI7XG4gICAgICAgIH0pXVxuICAgICAgfTtcbiAgICB9LFxuICAgIHBhdXNlQW5pbWF0aW9uOiBmdW5jdGlvbiBwYXVzZUFuaW1hdGlvbihzdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlLmFuaW1hdGlvbkZyYW1lUmVxdWVzdElkKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHN0YXRlLmFuaW1hdGlvbkZyYW1lUmVxdWVzdElkKTtcbiAgICAgICAgc3RhdGUuYW5pbWF0aW9uRnJhbWVSZXF1ZXN0SWQgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZXN1bWVBbmltYXRpb246IGZ1bmN0aW9uIHJlc3VtZUFuaW1hdGlvbihzdGF0ZSkge1xuICAgICAgaWYgKCFzdGF0ZS5hbmltYXRpb25GcmFtZVJlcXVlc3RJZCkge1xuICAgICAgICB0aGlzLl9hbmltYXRpb25DeWNsZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBfZGVzdHJ1Y3RvcjogZnVuY3Rpb24gX2Rlc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLnBhdXNlQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLmdyYXBoRGF0YSh7XG4gICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgbGlua3M6IFtdXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIGxpbmtlZE1ldGhvZHMpLFxuICBzdGF0ZUluaXQ6IGZ1bmN0aW9uIHN0YXRlSW5pdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGFzdFNldFpvb206IDEsXG4gICAgICB6b29tOiB6b29tKCksXG4gICAgICBmb3JjZUdyYXBoOiBuZXcgQ2FudmFzRm9yY2VHcmFwaCgpLFxuICAgICAgc2hhZG93R3JhcGg6IG5ldyBDYW52YXNGb3JjZUdyYXBoKCkuY29vbGRvd25UaWNrcygwKS5ub2RlQ29sb3IoJ19faW5kZXhDb2xvcicpLmxpbmtDb2xvcignX19pbmRleENvbG9yJykuaXNTaGFkb3codHJ1ZSksXG4gICAgICBjb2xvclRyYWNrZXI6IG5ldyBDb2xvclRyYWNrZXIoKSxcbiAgICAgIC8vIGluZGV4ZWQgb2JqZWN0cyBmb3IgcmdiIGxvb2t1cFxuICAgICAgdHdlZW5Hcm91cDogbmV3IEdyb3VwKClcbiAgICB9O1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KGRvbU5vZGUsIHN0YXRlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAvLyBXaXBlIERPTVxuICAgIGRvbU5vZGUuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAvLyBDb250YWluZXIgYW5jaG9yIGZvciBjYW52YXMgYW5kIHRvb2x0aXBcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2ZvcmNlLWdyYXBoLWNvbnRhaW5lcicpO1xuICAgIGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgZG9tTm9kZS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIHN0YXRlLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGlmIChzdGF0ZS5iYWNrZ3JvdW5kQ29sb3IpIHN0YXRlLmNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kID0gc3RhdGUuYmFja2dyb3VuZENvbG9yO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdGF0ZS5jYW52YXMpO1xuICAgIHN0YXRlLnNoYWRvd0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgLy8gU2hvdyBzaGFkb3cgY2FudmFzXG4gICAgLy9zdGF0ZS5zaGFkb3dDYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIC8vc3RhdGUuc2hhZG93Q2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICAvL3N0YXRlLnNoYWRvd0NhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgIC8vY29udGFpbmVyLmFwcGVuZENoaWxkKHN0YXRlLnNoYWRvd0NhbnZhcyk7XG5cbiAgICB2YXIgY3R4ID0gc3RhdGUuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIHNoYWRvd0N0eCA9IHN0YXRlLnNoYWRvd0NhbnZhcy5nZXRDb250ZXh0KCcyZCcsIHtcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgIH0pO1xuICAgIHZhciBwb2ludGVyUG9zID0ge1xuICAgICAgeDogLTFlMTIsXG4gICAgICB5OiAtMWUxMlxuICAgIH07XG4gICAgdmFyIGdldE9ialVuZGVyUG9pbnRlciA9IGZ1bmN0aW9uIGdldE9ialVuZGVyUG9pbnRlcigpIHtcbiAgICAgIHZhciBvYmogPSBudWxsO1xuICAgICAgdmFyIHB4U2NhbGUgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIHZhciBweCA9IHBvaW50ZXJQb3MueCA+IDAgJiYgcG9pbnRlclBvcy55ID4gMCA/IHNoYWRvd0N0eC5nZXRJbWFnZURhdGEocG9pbnRlclBvcy54ICogcHhTY2FsZSwgcG9pbnRlclBvcy55ICogcHhTY2FsZSwgMSwgMSkgOiBudWxsO1xuICAgICAgLy8gTG9va3VwIG9iamVjdCBwZXIgcGl4ZWwgY29sb3JcbiAgICAgIHB4ICYmIChvYmogPSBzdGF0ZS5jb2xvclRyYWNrZXIubG9va3VwKHB4LmRhdGEpKTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuICAgIC8vIFNldHVwIG5vZGUgZHJhZyBpbnRlcmFjdGlvblxuICAgIHNlbGVjdChzdGF0ZS5jYW52YXMpLmNhbGwoZHJhZygpLnN1YmplY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzdGF0ZS5lbmFibGVOb2RlRHJhZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSBnZXRPYmpVbmRlclBvaW50ZXIoKTtcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLnR5cGUgPT09ICdOb2RlJyA/IG9iai5kIDogbnVsbDsgLy8gT25seSBkcmFnIG5vZGVzXG4gICAgfSkub24oJ3N0YXJ0JywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgb2JqID0gZXYuc3ViamVjdDtcbiAgICAgIG9iai5fX2luaXRpYWxEcmFnUG9zID0ge1xuICAgICAgICB4OiBvYmoueCxcbiAgICAgICAgeTogb2JqLnksXG4gICAgICAgIGZ4OiBvYmouZngsXG4gICAgICAgIGZ5OiBvYmouZnlcbiAgICAgIH07XG5cbiAgICAgIC8vIGtlZXAgZW5naW5lIHJ1bm5pbmcgYXQgbG93IGludGVuc2l0eSB0aHJvdWdob3V0IGRyYWdcbiAgICAgIGlmICghZXYuYWN0aXZlKSB7XG4gICAgICAgIG9iai5meCA9IG9iai54O1xuICAgICAgICBvYmouZnkgPSBvYmoueTsgLy8gRml4IHBvaW50c1xuICAgICAgfVxuXG4gICAgICAvLyBkcmFnIGN1cnNvclxuICAgICAgc3RhdGUuY2FudmFzLmNsYXNzTGlzdC5hZGQoJ2dyYWJiYWJsZScpO1xuICAgIH0pLm9uKCdkcmFnJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgb2JqID0gZXYuc3ViamVjdDtcbiAgICAgIHZhciBpbml0UG9zID0gb2JqLl9faW5pdGlhbERyYWdQb3M7XG4gICAgICB2YXIgZHJhZ1BvcyA9IGV2O1xuICAgICAgdmFyIGsgPSB6b29tVHJhbnNmb3JtKHN0YXRlLmNhbnZhcykuaztcbiAgICAgIHZhciB0cmFuc2xhdGUgPSB7XG4gICAgICAgIHg6IGluaXRQb3MueCArIChkcmFnUG9zLnggLSBpbml0UG9zLngpIC8gayAtIG9iai54LFxuICAgICAgICB5OiBpbml0UG9zLnkgKyAoZHJhZ1Bvcy55IC0gaW5pdFBvcy55KSAvIGsgLSBvYmoueVxuICAgICAgfTtcblxuICAgICAgLy8gTW92ZSBmeC9meSAoYW5kIHgveSkgb2Ygbm9kZXMgYmFzZWQgb24gdGhlIHNjYWxlZCBkcmFnIGRpc3RhbmNlIHNpbmNlIHRoZSBkcmFnIHN0YXJ0XG4gICAgICBbJ3gnLCAneSddLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIG9ialtcImZcIi5jb25jYXQoYyldID0gb2JqW2NdID0gaW5pdFBvc1tjXSArIChkcmFnUG9zW2NdIC0gaW5pdFBvc1tjXSkgLyBrO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE9ubHkgZW5nYWdlIGZ1bGwgZHJhZyBpZiBkaXN0YW5jZSByZWFjaGVzIGFib3ZlIHRocmVzaG9sZFxuICAgICAgaWYgKCFvYmouX19kcmFnZ2VkICYmIERSQUdfQ0xJQ0tfVE9MRVJBTkNFX1BYID49IE1hdGguc3FydChzdW0oWyd4JywgJ3knXS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KGV2W2tdIC0gaW5pdFBvc1trXSwgMik7XG4gICAgICB9KSkpKSByZXR1cm47XG4gICAgICBzdGF0ZS5mb3JjZUdyYXBoLmQzQWxwaGFUYXJnZXQoMC4zKSAvLyBrZWVwIGVuZ2luZSBydW5uaW5nIGF0IGxvdyBpbnRlbnNpdHkgdGhyb3VnaG91dCBkcmFnXG4gICAgICAucmVzZXRDb3VudGRvd24oKTsgLy8gcHJldmVudCBmcmVlemUgd2hpbGUgZHJhZ2dpbmdcblxuICAgICAgc3RhdGUuaXNQb2ludGVyRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgb2JqLl9fZHJhZ2dlZCA9IHRydWU7XG4gICAgICBzdGF0ZS5vbk5vZGVEcmFnKG9iaiwgdHJhbnNsYXRlKTtcbiAgICB9KS5vbignZW5kJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgb2JqID0gZXYuc3ViamVjdDtcbiAgICAgIHZhciBpbml0UG9zID0gb2JqLl9faW5pdGlhbERyYWdQb3M7XG4gICAgICB2YXIgdHJhbnNsYXRlID0ge1xuICAgICAgICB4OiBvYmoueCAtIGluaXRQb3MueCxcbiAgICAgICAgeTogb2JqLnkgLSBpbml0UG9zLnlcbiAgICAgIH07XG4gICAgICBpZiAoaW5pdFBvcy5meCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9iai5meCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChpbml0UG9zLmZ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2JqLmZ5ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgZGVsZXRlIG9iai5fX2luaXRpYWxEcmFnUG9zO1xuICAgICAgaWYgKHN0YXRlLmZvcmNlR3JhcGguZDNBbHBoYVRhcmdldCgpKSB7XG4gICAgICAgIHN0YXRlLmZvcmNlR3JhcGguZDNBbHBoYVRhcmdldCgwKSAvLyByZWxlYXNlIGVuZ2luZSBsb3cgaW50ZW5zaXR5XG4gICAgICAgIC5yZXNldENvdW50ZG93bigpOyAvLyBsZXQgdGhlIGVuZ2luZSByZWFkanVzdCBhZnRlciByZWxlYXNpbmcgZml4ZWQgbm9kZXNcbiAgICAgIH1cblxuICAgICAgLy8gZHJhZyBjdXJzb3JcbiAgICAgIHN0YXRlLmNhbnZhcy5jbGFzc0xpc3QucmVtb3ZlKCdncmFiYmFibGUnKTtcbiAgICAgIHN0YXRlLmlzUG9pbnRlckRyYWdnaW5nID0gZmFsc2U7XG4gICAgICBpZiAob2JqLl9fZHJhZ2dlZCkge1xuICAgICAgICBkZWxldGUgb2JqLl9fZHJhZ2dlZDtcbiAgICAgICAgc3RhdGUub25Ob2RlRHJhZ0VuZChvYmosIHRyYW5zbGF0ZSk7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgLy8gU2V0dXAgem9vbSAvIHBhbiBpbnRlcmFjdGlvblxuICAgIHN0YXRlLnpvb20oc3RhdGUuem9vbS5fX2Jhc2VFbGVtID0gc2VsZWN0KHN0YXRlLmNhbnZhcykpOyAvLyBBdHRhY2ggY29udHJvbGxpbmcgZWxlbSBmb3IgZWFzeSBhY2Nlc3NcblxuICAgIHN0YXRlLnpvb20uX19iYXNlRWxlbS5vbignZGJsY2xpY2suem9vbScsIG51bGwpOyAvLyBEaXNhYmxlIGRvdWJsZS1jbGljayB0byB6b29tXG5cbiAgICBzdGF0ZS56b29tLmZpbHRlcihmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIC8vIGRpc2FibGUgem9vbSBpbnRlcmFjdGlvblxuICAgICAgICAhZXYuYnV0dG9uICYmIHN0YXRlLmVuYWJsZVpvb21QYW5JbnRlcmFjdGlvbiAmJiAoZXYudHlwZSAhPT0gJ3doZWVsJyB8fCBhY2Nlc3NvckZuKHN0YXRlLmVuYWJsZVpvb21JbnRlcmFjdGlvbikoZXYpKSAmJiAoZXYudHlwZSA9PT0gJ3doZWVsJyB8fCBhY2Nlc3NvckZuKHN0YXRlLmVuYWJsZVBhbkludGVyYWN0aW9uKShldikpXG4gICAgICApO1xuICAgIH0pLm9uKCd6b29tJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgdCA9IGV2LnRyYW5zZm9ybTtcbiAgICAgIFtjdHgsIHNoYWRvd0N0eF0uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICByZXNldFRyYW5zZm9ybShjKTtcbiAgICAgICAgYy50cmFuc2xhdGUodC54LCB0LnkpO1xuICAgICAgICBjLnNjYWxlKHQuaywgdC5rKTtcbiAgICAgIH0pO1xuICAgICAgc3RhdGUuaXNQb2ludGVyRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgc3RhdGUub25ab29tICYmIHN0YXRlLm9uWm9vbShfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgdCksIF90aGlzLmNlbnRlckF0KCkpKTsgLy8gcmVwb3J0IHgseSBjb29yZGluYXRlcyByZWxhdGl2ZSB0byBjYW52YXMgY2VudGVyXG4gICAgICBzdGF0ZS5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgfSkub24oJ2VuZCcsIGZ1bmN0aW9uIChldikge1xuICAgICAgc3RhdGUuaXNQb2ludGVyRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm9uWm9vbUVuZCAmJiBzdGF0ZS5vblpvb21FbmQoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGV2LnRyYW5zZm9ybSksIF90aGlzLmNlbnRlckF0KCkpKTtcbiAgICB9KTtcbiAgICBhZGp1c3RDYW52YXNTaXplKHN0YXRlKTtcbiAgICBzdGF0ZS5mb3JjZUdyYXBoLm9uTmVlZHNSZWRyYXcoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICB9KS5vbkZpbmlzaFVwZGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAvLyByZS16b29tLCBpZiBzdGlsbCBpbiBkZWZhdWx0IHBvc2l0aW9uIChub3QgdXNlciBtb2RpZmllZClcbiAgICAgIGlmICh6b29tVHJhbnNmb3JtKHN0YXRlLmNhbnZhcykuayA9PT0gc3RhdGUubGFzdFNldFpvb20gJiYgc3RhdGUuZ3JhcGhEYXRhLm5vZGVzLmxlbmd0aCkge1xuICAgICAgICBzdGF0ZS56b29tLnNjYWxlVG8oc3RhdGUuem9vbS5fX2Jhc2VFbGVtLCBzdGF0ZS5sYXN0U2V0Wm9vbSA9IFpPT00yTk9ERVNfRkFDVE9SIC8gTWF0aC5jYnJ0KHN0YXRlLmdyYXBoRGF0YS5ub2Rlcy5sZW5ndGgpKTtcbiAgICAgICAgc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU2V0dXAgdG9vbHRpcFxuICAgIHN0YXRlLnRvb2x0aXAgPSBuZXcgVG9vbHRpcChjb250YWluZXIpO1xuXG4gICAgLy8gQ2FwdHVyZSBwb2ludGVyIGNvb3JkcyBvbiBtb3ZlIG9yIHRvdWNoc3RhcnRcbiAgICBbJ3BvaW50ZXJtb3ZlJywgJ3BvaW50ZXJkb3duJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZUeXBlKSB7XG4gICAgICByZXR1cm4gY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoZXZUeXBlLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgaWYgKGV2VHlwZSA9PT0gJ3BvaW50ZXJkb3duJykge1xuICAgICAgICAgIHN0YXRlLmlzUG9pbnRlclByZXNzZWQgPSB0cnVlOyAvLyB0cmFjayBjbGljayBzdGF0ZVxuICAgICAgICAgIHN0YXRlLnBvaW50ZXJEb3duRXZlbnQgPSBldjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRldGVjdCBwb2ludGVyIGRyYWcgb24gY2FudmFzIHBhblxuICAgICAgICAhc3RhdGUuaXNQb2ludGVyRHJhZ2dpbmcgJiYgZXYudHlwZSA9PT0gJ3BvaW50ZXJtb3ZlJyAmJiBzdGF0ZS5vbkJhY2tncm91bmRDbGljayAvLyBvbmx5IGJvdGhlciBkZXRlY3RpbmcgZHJhZ3MgdGhpcyB3YXkgaWYgYmFja2dyb3VuZCBjbGlja3MgYXJlIGVuYWJsZWQgKHNvIHRoZXkgZG9uJ3QgdHJpZ2dlciBhY2NpZGVudGFsbHkgb24gY2FudmFzIHBhbm5pbmcpXG4gICAgICAgICYmIChldi5wcmVzc3VyZSA+IDAgfHwgc3RhdGUuaXNQb2ludGVyUHJlc3NlZCkgLy8gZXYucHJlc3N1cmUgYWx3YXlzIDAgb24gU2FmYXJpLCBzbyB3ZSB1c2UgdGhlIGlzUG9pbnRlclByZXNzZWQgdHJhY2tlclxuICAgICAgICAmJiAoZXYucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZXYubW92ZW1lbnRYID09PSB1bmRlZmluZWQgfHwgW2V2Lm1vdmVtZW50WCwgZXYubW92ZW1lbnRZXS5zb21lKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKG0pID4gMTtcbiAgICAgICAgfSkpIC8vIHJlbGF4IGRyYWcgdHJpZ2dlciBzZW5zaXRpdml0eSBvbiBub24tbW91c2UgKHRvdWNoL3BlbikgZXZlbnRzXG4gICAgICAgICYmIChzdGF0ZS5pc1BvaW50ZXJEcmFnZ2luZyA9IHRydWUpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgcG9pbnRlciBwb3NcbiAgICAgICAgdmFyIG9mZnNldCA9IGdldE9mZnNldChjb250YWluZXIpO1xuICAgICAgICBwb2ludGVyUG9zLnggPSBldi5wYWdlWCAtIG9mZnNldC5sZWZ0O1xuICAgICAgICBwb2ludGVyUG9zLnkgPSBldi5wYWdlWSAtIG9mZnNldC50b3A7XG5cbiAgICAgICAgLy9cblxuICAgICAgICBmdW5jdGlvbiBnZXRPZmZzZXQoZWwpIHtcbiAgICAgICAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHNjcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IHJlY3QudG9wICsgc2Nyb2xsVG9wLFxuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgc2Nyb2xsTGVmdFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgY2xpY2svdG91Y2ggZXZlbnRzIG9uIG5vZGVzL2xpbmtzXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGZ1bmN0aW9uIChldikge1xuICAgICAgaWYgKCFzdGF0ZS5pc1BvaW50ZXJQcmVzc2VkKSB7XG4gICAgICAgIHJldHVybjsgLy8gZG9uJ3QgdHJpZ2dlciBjbGljayBldmVudHMgaWYgcG9pbnRlciBpcyBub3QgcHJlc3NlZCBvbiB0aGUgY2FudmFzXG4gICAgICB9XG4gICAgICBzdGF0ZS5pc1BvaW50ZXJQcmVzc2VkID0gZmFsc2U7XG4gICAgICBpZiAoc3RhdGUuaXNQb2ludGVyRHJhZ2dpbmcpIHtcbiAgICAgICAgc3RhdGUuaXNQb2ludGVyRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuOyAvLyBkb24ndCB0cmlnZ2VyIGNsaWNrIGV2ZW50cyBhZnRlciBwb2ludGVyIGRyYWcgKHBhbiAvIG5vZGUgZHJhZyBmdW5jdGlvbmFsaXR5KVxuICAgICAgfVxuICAgICAgdmFyIGNiRXZlbnRzID0gW2V2LCBzdGF0ZS5wb2ludGVyRG93bkV2ZW50XTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2xpY2sgZXZlbnRzIGFzeW5jaHJvbm91c2x5LCB0byBhbGxvdyBob3Zlck9iaiB0byBiZSBzZXQgKG9uIGZyYW1lKVxuICAgICAgICBpZiAoZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgLy8gbW91c2UgbGVmdC1jbGljayBvciB0b3VjaFxuICAgICAgICAgIGlmIChzdGF0ZS5ob3Zlck9iaikge1xuICAgICAgICAgICAgdmFyIGZuID0gc3RhdGVbXCJvblwiLmNvbmNhdChzdGF0ZS5ob3Zlck9iai50eXBlLCBcIkNsaWNrXCIpXTtcbiAgICAgICAgICAgIGZuICYmIGZuLmFwcGx5KHZvaWQgMCwgW3N0YXRlLmhvdmVyT2JqLmRdLmNvbmNhdChjYkV2ZW50cykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5vbkJhY2tncm91bmRDbGljayAmJiBzdGF0ZS5vbkJhY2tncm91bmRDbGljay5hcHBseShzdGF0ZSwgY2JFdmVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXYuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgLy8gbW91c2UgcmlnaHQtY2xpY2tcbiAgICAgICAgICBpZiAoc3RhdGUuaG92ZXJPYmopIHtcbiAgICAgICAgICAgIHZhciBfZm4gPSBzdGF0ZVtcIm9uXCIuY29uY2F0KHN0YXRlLmhvdmVyT2JqLnR5cGUsIFwiUmlnaHRDbGlja1wiKV07XG4gICAgICAgICAgICBfZm4gJiYgX2ZuLmFwcGx5KHZvaWQgMCwgW3N0YXRlLmhvdmVyT2JqLmRdLmNvbmNhdChjYkV2ZW50cykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5vbkJhY2tncm91bmRSaWdodENsaWNrICYmIHN0YXRlLm9uQmFja2dyb3VuZFJpZ2h0Q2xpY2suYXBwbHkoc3RhdGUsIGNiRXZlbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIGlmICghc3RhdGUub25CYWNrZ3JvdW5kUmlnaHRDbGljayAmJiAhc3RhdGUub25Ob2RlUmlnaHRDbGljayAmJiAhc3RhdGUub25MaW5rUmlnaHRDbGljaykgcmV0dXJuIHRydWU7IC8vIGRlZmF1bHQgY29udGV4dG1lbnUgYmVoYXZpb3JcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgc3RhdGUuZm9yY2VHcmFwaChjdHgpO1xuICAgIHN0YXRlLnNoYWRvd0dyYXBoKHNoYWRvd0N0eCk7XG5cbiAgICAvL1xuXG4gICAgdmFyIHJlZnJlc2hTaGFkb3dDYW52YXMgPSB0aHJvdHRsZShmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB3aXBlIGNhbnZhc1xuICAgICAgY2xlYXJDYW52YXMoc2hhZG93Q3R4LCBzdGF0ZS53aWR0aCwgc3RhdGUuaGVpZ2h0KTtcblxuICAgICAgLy8gQWRqdXN0IGxpbmsgaG92ZXIgYXJlYVxuICAgICAgc3RhdGUuc2hhZG93R3JhcGgubGlua1dpZHRoKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHJldHVybiBhY2Nlc3NvckZuKHN0YXRlLmxpbmtXaWR0aCkobCkgKyBzdGF0ZS5saW5rSG92ZXJQcmVjaXNpb247XG4gICAgICB9KTtcblxuICAgICAgLy8gcmVkcmF3XG4gICAgICB2YXIgdCA9IHpvb21UcmFuc2Zvcm0oc3RhdGUuY2FudmFzKTtcbiAgICAgIHN0YXRlLnNoYWRvd0dyYXBoLmdsb2JhbFNjYWxlKHQuaykudGlja0ZyYW1lKCk7XG4gICAgfSwgSE9WRVJfQ0FOVkFTX1RIUk9UVExFX0RFTEFZKTtcbiAgICBzdGF0ZS5mbHVzaFNoYWRvd0NhbnZhcyA9IHJlZnJlc2hTaGFkb3dDYW52YXMuZmx1c2g7IC8vIGhvb2sgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHNoYWRvdyBjYW52YXMgcGFpbnRcblxuICAgIC8vIEtpY2stb2ZmIHJlbmRlcmVyXG4gICAgKHRoaXMuX2FuaW1hdGlvbkN5Y2xlID0gZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICAgIC8vIElJRkVcbiAgICAgIHZhciBkb1JlZHJhdyA9ICFzdGF0ZS5hdXRvUGF1c2VSZWRyYXcgfHwgISFzdGF0ZS5uZWVkc1JlZHJhdyB8fCBzdGF0ZS5mb3JjZUdyYXBoLmlzRW5naW5lUnVubmluZygpIHx8IHN0YXRlLmdyYXBoRGF0YS5saW5rcy5zb21lKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLl9fcGhvdG9ucyAmJiBkLl9fcGhvdG9ucy5sZW5ndGg7XG4gICAgICB9KTtcbiAgICAgIHN0YXRlLm5lZWRzUmVkcmF3ID0gZmFsc2U7XG4gICAgICBpZiAoc3RhdGUuZW5hYmxlUG9pbnRlckludGVyYWN0aW9uKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0b29sdGlwIGFuZCB0cmlnZ2VyIG9uSG92ZXIgZXZlbnRzXG4gICAgICAgIHZhciBvYmogPSAhc3RhdGUuaXNQb2ludGVyRHJhZ2dpbmcgPyBnZXRPYmpVbmRlclBvaW50ZXIoKSA6IG51bGw7IC8vIGRvbid0IGhvdmVyIGR1cmluZyBkcmFnXG4gICAgICAgIGlmIChvYmogIT09IHN0YXRlLmhvdmVyT2JqKSB7XG4gICAgICAgICAgdmFyIHByZXZPYmogPSBzdGF0ZS5ob3Zlck9iajtcbiAgICAgICAgICB2YXIgcHJldk9ialR5cGUgPSBwcmV2T2JqID8gcHJldk9iai50eXBlIDogbnVsbDtcbiAgICAgICAgICB2YXIgb2JqVHlwZSA9IG9iaiA/IG9iai50eXBlIDogbnVsbDtcbiAgICAgICAgICBpZiAocHJldk9ialR5cGUgJiYgcHJldk9ialR5cGUgIT09IG9ialR5cGUpIHtcbiAgICAgICAgICAgIC8vIEhvdmVyIG91dFxuICAgICAgICAgICAgdmFyIGZuID0gc3RhdGVbXCJvblwiLmNvbmNhdChwcmV2T2JqVHlwZSwgXCJIb3ZlclwiKV07XG4gICAgICAgICAgICBmbiAmJiBmbihudWxsLCBwcmV2T2JqLmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqVHlwZSkge1xuICAgICAgICAgICAgLy8gSG92ZXIgaW5cbiAgICAgICAgICAgIHZhciBfZm4yID0gc3RhdGVbXCJvblwiLmNvbmNhdChvYmpUeXBlLCBcIkhvdmVyXCIpXTtcbiAgICAgICAgICAgIF9mbjIgJiYgX2ZuMihvYmouZCwgcHJldk9ialR5cGUgPT09IG9ialR5cGUgPyBwcmV2T2JqLmQgOiBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdGUudG9vbHRpcC5jb250ZW50KG9iaiA/IGFjY2Vzc29yRm4oc3RhdGVbXCJcIi5jb25jYXQob2JqLnR5cGUudG9Mb3dlckNhc2UoKSwgXCJMYWJlbFwiKV0pKG9iai5kKSB8fCBudWxsIDogbnVsbCk7XG5cbiAgICAgICAgICAvLyBzZXQgcG9pbnRlciBpZiBob3ZlcmVkIG9iamVjdCBpcyBjbGlja2FibGVcbiAgICAgICAgICBzdGF0ZS5jYW52YXMuY2xhc3NMaXN0WyhvYmogJiYgc3RhdGVbXCJvblwiLmNvbmNhdChvYmpUeXBlLCBcIkNsaWNrXCIpXSB8fCAhb2JqICYmIHN0YXRlLm9uQmFja2dyb3VuZENsaWNrKSAmJiBhY2Nlc3NvckZuKHN0YXRlLnNob3dQb2ludGVyQ3Vyc29yKShvYmogPT09IG51bGwgfHwgb2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmouZCkgPyAnYWRkJyA6ICdyZW1vdmUnXSgnY2xpY2thYmxlJyk7XG4gICAgICAgICAgc3RhdGUuaG92ZXJPYmogPSBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgZG9SZWRyYXcgJiYgcmVmcmVzaFNoYWRvd0NhbnZhcygpO1xuICAgICAgfVxuICAgICAgaWYgKGRvUmVkcmF3KSB7XG4gICAgICAgIC8vIFdpcGUgY2FudmFzXG4gICAgICAgIGNsZWFyQ2FudmFzKGN0eCwgc3RhdGUud2lkdGgsIHN0YXRlLmhlaWdodCk7XG5cbiAgICAgICAgLy8gRnJhbWUgY3ljbGVcbiAgICAgICAgdmFyIGdsb2JhbFNjYWxlID0gem9vbVRyYW5zZm9ybShzdGF0ZS5jYW52YXMpLms7XG4gICAgICAgIHN0YXRlLm9uUmVuZGVyRnJhbWVQcmUgJiYgc3RhdGUub25SZW5kZXJGcmFtZVByZShjdHgsIGdsb2JhbFNjYWxlKTtcbiAgICAgICAgc3RhdGUuZm9yY2VHcmFwaC5nbG9iYWxTY2FsZShnbG9iYWxTY2FsZSkudGlja0ZyYW1lKCk7XG4gICAgICAgIHN0YXRlLm9uUmVuZGVyRnJhbWVQb3N0ICYmIHN0YXRlLm9uUmVuZGVyRnJhbWVQb3N0KGN0eCwgZ2xvYmFsU2NhbGUpO1xuICAgICAgfVxuICAgICAgc3RhdGUudHdlZW5Hcm91cC51cGRhdGUoKTsgLy8gdXBkYXRlIGNhbnZhcyBhbmltYXRpb24gdHdlZW5zXG5cbiAgICAgIHN0YXRlLmFuaW1hdGlvbkZyYW1lUmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgIH0pKCk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlRm4oc3RhdGUpIHt9XG59KTtcblxuZXhwb3J0IHsgZm9yY2VHcmFwaCBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/force-graph/dist/force-graph.mjs\n");

/***/ })

};
;